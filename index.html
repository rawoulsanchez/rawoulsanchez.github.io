
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>All B6</title>
<style>
  /* Design tokens */
:root { --bg:#000; --fg:#eaeaf0; --muted:#9aa0a6; --accent:#7aa2ff; --nav-height:64px; --brand:#e31b23; --brand-glow-shadow:0 0 8px var(--brand), 0 0 24px color-mix(in srgb, var(--brand) 60%, transparent 40%); --preview-frame-radius:18px; --preview-frame-border:1px solid #262b33; --preview-frame-shadow:0 22px 60px rgba(0,0,0,0.80), 0 0 0 1px rgba(255,255,255,0.03), var(--brand-glow-shadow); --preview-morph-duration:340ms; --preview-morph-ease:cubic-bezier(0.22, 0.61, 0.36, 1); }
  :root{
  --font-ui: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  --font-display: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
}
  * { box-sizing:border-box; }
  body { margin:0; font-family:var(--font-ui); background:var(--bg); color:var(--fg); line-height:1.5; overflow-x:hidden; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }

  /* Fixed black nav */
.nav-bar{
  position:fixed;
  top:0;
  left:0;
  right:0;
  z-index:100;
  background:#000;
  height:calc(var(--nav-height) + env(safe-area-inset-top));
  box-shadow:none;
border-bottom:0;
}

/* Content sits below the notch area */
.nav-inner {
  max-width:960px;
  margin:0 auto;
  height:var(--nav-height);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  padding:env(safe-area-inset-top) 16px 0 16px; /* <-- moved from .nav-bar */
}
.brand {
    color:var(--brand);
    font-weight:800;
    font-size:24px;
    letter-spacing:.2px;
    text-decoration:none;
}
  .nav-links{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:18px;
    margin:0 24px;
    flex:1 1 auto;
    min-width:0;
    white-space:nowrap;
  }
  .nav-link{
    font-size:.82rem;
    font-weight:500;
    color:var(--muted);
    text-decoration:none;
    padding:4px 8px;
    border-radius:999px;
    transition:color .16s ease, background-color .16s ease, opacity .16s ease;
  }
  .nav-link:hover{
    color:var(--fg);
    background:#111;
  }
  .nav-link--active{
    color:#fff;
    background:rgba(255,255,255,0.10);
  }
  @media (max-width:640px){
    .nav-links{
      gap:12px;
      margin:0 12px;
      font-size:.78rem;
      white-space:normal;
      flex-wrap:wrap;
      justify-content:flex-start;
    }
    .nav-link{
      font-size:.78rem;
      padding:3px 6px;
    }
  }
  .nav-actions {
    display:flex;
    gap:12px;
    align-items:center;
  }
  .icon-btn {
    position:relative;
    display:inline-grid;
    place-items:center;
    width:36px;
    height:36px;
    border-radius:999px;
    background:#121212;
    border:1px solid #222;
    cursor:pointer;
    color:#eaeaf0;
  }
  .icon-btn:hover { background:#161616; }
  .icon-btn svg { fill:currentColor; }
.icon-btn .dot {
    position:absolute;
    top:4px;
    right:4px;
    width:9px;
    height:9px;
    background:var(--brand);
    border-radius:999px;
    box-shadow:0 0 0 2px #000;
}
  .title-chip{
  display:inline-flex; align-items:center; justify-content:center;
  padding:.5rem .875rem;
  background:rgba(17,17,17,.85);
  border-radius:.75rem;
  /* keep same visual weight and red border using token */
  box-shadow:
    0 6px 20px rgba(0,0,0,.45),
    inset 0 0 0 2px color-mix(in srgb, var(--brand) 65%, transparent);
  margin-bottom:.5rem;         /* preserves your current spacing */
}
.title-chip-text{
  font-family: var(--font-display);
  font-weight:800;
  letter-spacing:.08em;
  color:#fff;
  font-size:clamp(1rem,2.6vw,1.35rem);
}

/* Optional responsive tweak, mirrors your sample without Tailwind */
@media (max-width:768px){
  .title-chip{ padding:.4rem .75rem; }
  .title-chip-text{ letter-spacing:.09em; }
}
@media (min-width:768px){
  .title-chip-text{ font-size:1.35rem; } /* matches clampâ€™s max */
}

/* Layout helpers used by the page */
/* Keep hero flush under fixed nav (hide the 1px inset line) */
main{
  /* 1px upward overlap to kill rounding sliver on DPR 2/3 */
  padding-top: calc(var(--nav-height) + env(safe-area-inset-top) - 1px);
}
.wrap {
  max-width:960px;
  margin:0 auto;
  padding:16px;
}
/* REMOVED .wrap--flush to simplify structure. The horizontal gap fix requires this. */
.card {
  background:#14161c;
  border:1px solid #222;
  border-radius:12px;
  padding:16px;
  margin:16px;
}
  footer {
    color:var(--muted);
    text-align:center;
    padding:24px;
    border-top:1px solid #222;
    font-size:.82rem;
  }
  .footer-nav{
    margin-top:6px;
    display:flex;
    flex-wrap:wrap;
    justify-content:center;
    gap:4px 10px;
    font-size:.78rem;
  }
  .footer-nav-link{
    position:relative;
    color:var(--muted);
    text-decoration:none;
    transition:color .16s ease, opacity .16s ease;
  }
  .footer-nav-link:hover{
    color:var(--fg);
  }
  .footer-nav-link::before{
    content:"â€¢";
    opacity:.6;
    margin:0 6px 0 2px;
  }
  .footer-nav-link:first-child::before{
    content:"";
    margin:0;
  }
  button.cta {
    background:var(--accent);
    color:#0b1020;
    border:0;
    padding:10px 14px;
    border-radius:10px;
    font-weight:600;
    cursor:pointer;
  }
  button.cta:focus {
    outline:2px solid #fff4;
    outline-offset:2px;
  }
  h1 { font-size:clamp(28px,4vw,40px); margin:0 0 8px; }
  h2 { font-size:clamp(18px,4.5vw,24px); margin:12px 0 8px; }
  p  { margin:8px 0; color:var(--muted); }

/* HERO */
.hero{
  position:relative;
  height:auto;
  aspect-ratio:16 / 9;
  overflow:hidden;             /* crops the overfill from the iframe */
  background:#000;
  width:170vw;
  left:50%;
  transform: translateX(-50%);
  z-index:1;
  margin-top:-2px;             /* touch the nav */
  border-top:0;
}

.hero-video { position:absolute; inset:0; opacity:1; transition: opacity 400ms ease; }
.hero-video.is-hero-fadeout{ opacity:0; }

/* Cover + crop bottom WITHOUT clip-path */
.hero-video iframe{
  position:absolute;
  inset:0;
  width:170vw;
  height:112%;                 /* overfill vertically */
  left:50%;
  transform:translate(-50%, -6%); /* shift up to crop bottom */
  border:0;
}

/* Black spacer under the hero - NOW RESPONSIBLE FOR FULL WIDTH COVERAGE */
.after-hero{
  min-height:0; /* reduced to remove large gap below Row A */
  background:#000;
  border:0;
  margin:0;
  border-radius:0;
  padding:0; /* Ensure no padding on the .after-hero so the black background is full width */
  margin-top:0; /* pull pills closer to synopsis */
}

/* New wrapper to correctly apply padding and center content within the full-width black section */
.content-pad {
  max-width:960px;
  margin:0 auto;
  /* Apply responsive padding only to the content wrapper */
  padding: 0 calc(16px + env(safe-area-inset-right)) 16px calc(16px + env(safe-area-inset-left));
}


/* Hero gradient: bottom â†’ top, covers full hero */
.hero-gradient{
  position:absolute;
  inset:0;                    /* cover full hero box */
  z-index:1;                  /* video (0) < gradient (1) < overlay (2) */
  pointer-events:none;
  transform:translateZ(0);
  backface-visibility:hidden;
  background:linear-gradient(
    to top,
    rgba(0,0,0,0.88) 0%,
    rgba(0,0,0,0.76) 10%,
    rgba(0,0,0,0.60) 22%,
    rgba(0,0,0,0.42) 36%,
    rgba(0,0,0,0.26) 52%,
    rgba(0,0,0,0.14) 68%,
    rgba(0,0,0,0.00) 100%
  );
}

@media (max-width:600px){
  .hero-gradient{
    background:linear-gradient(
      to top,
      rgba(0,0,0,0.92) 0%,
      rgba(0,0,0,0.80) 12%,
      rgba(0,0,0,0.64) 26%,
      rgba(0,0,0,0.46) 40%,
      rgba(0,0,0,0.28) 56%,
      rgba(0,0,0,0.14) 72%,
      rgba(0,0,0,0.00) 100%
    );
  }
}

.hero-text {
  padding:64px 0;
  display:grid;
  gap:16px;
}
@media (max-width:600px) {
  .hero-text { padding:48px 0; }
}

  /* Apply drop shadow to all overlay text */
.hero-overlay-inline,
.hero-overlay-inline * {
  text-shadow: 0 1px 3px rgba(0,0,0,0.70);
}

/* Stronger shadow for the synopsis for readability */
.hero-overlay-inline .hero-synopsis {
  text-shadow: 0 2px 6px rgba(0,0,0,0.85);
}

/* Mute button */
  .mute-btn {
    position:absolute;
    right:12px;
    bottom:12px;
    width:40px;
    height:40px;
    border-radius:999px;
    border:1px solid #222;
    background:#121212;
    color:#eaeaf0;
    display:grid;
    place-items:center;
    font-size:18px;
    cursor:pointer;
  }
  .mute-btn:focus {
    outline:2px solid #fff4;
    outline-offset:2px;
  }
  /* commit: no-horizontal-scroll */
html { overflow-x: hidden; }
/* ZAQ TASK â€” PREVIEW SCROLL LOCK: reserve scrollbar space to prevent layout shift */
html { scrollbar-gutter: stable; }

/* CTA row under the hero video */
.hero-cta{
  display:grid;
  grid-template-columns: 1fr 1fr;   /* always two columns */
  gap:8px;
  width:100%;
  max-width:340px;                   /* keep pills on one line */
  margin: calc(8px + .125rem) 0 0 0; /* FIXED gap below synopsis */
}

/* Smaller buttons */
.btn{
  appearance:none; border:0; cursor:pointer;
  display:inline-flex; align-items:center; justify-content:center;
  gap:.35rem; padding:.42rem .56rem; border-radius:999px; /* same height, narrower */
  font:700 .80rem/1 var(--font-ui);
  transition:transform .12s ease, opacity .12s ease, box-shadow .12s ease, background .12s ease;
  width:100%;
  box-shadow: 0 6px 14px rgba(0,0,0,.18);
}
.btn:focus{ outline:2px solid #ffffff33; outline-offset:2px; }
.btn:active{ transform: translateY(1px); }

.btn--solid{ background:#fff; color:#000; }
.btn--solid:hover{ background:#e6e6e6; }

.btn--ghost{
  background: rgba(255,255,255,0.10); color:#fff;
  box-shadow: inset 0 0 0 1.1px rgba(255,255,255,0.28);
}
.btn--ghost:hover{ box-shadow: inset 0 0 0 1.1px rgba(255,255,255,0.5); }

/* Smaller icons */
.btn svg{ width:14px; height:14px; display:block; } /* matches reduced height */
.btn--solid:hover{ background:#e6e6e6; }

.btn--ghost{
  background: rgba(255,255,255,0.10); color:#fff;
  box-shadow: inset 0 0 0 1.25px rgba(255,255,255,0.28);
}
.btn--ghost:hover{ box-shadow: inset 0 0 0 1.25px rgba(255,255,255,0.5); }

/* Smaller icons */
.btn svg{ width:16px; height:16px; display:block; }

/* REMOVED: ALWAYS-ON GAP CHECK BACKGROUND */
/* =============================
   Shelves (Rows A/B/C)
   ============================= */
:root{ --shelf-gap:4px; --shelf-radius:14px; }
.shelf{ margin:0; }
.shelf-title{ font:700 1rem/1.3 var(--font-ui); color:var(--fg); margin:0 0 6px; position:relative; transform:translateY(var(--shelf-title-shift-mobile)); }
.shelf-divider{ height:2px; background:#3a3f46; opacity:.9; border-radius:2px; }
/* Full-bleed wrapper so the track can extend to viewport edges */
.shelf-outer{ position:relative; width:100vw; left:50%; transform:translateX(-50%); }
/* Edge fades (narrow 48px) */
.shelf-outer::before, .shelf-outer::after{
  content:""; position:absolute; top:0; bottom:0; width:120px; pointer-events:none; z-index:2;
}
.shelf-outer::before{
  left:0;
  background:linear-gradient(
    to right,
    rgba(0,0,0,1) 0%,
    rgba(0,0,0,0.88) 20%,
    rgba(0,0,0,0.60) 45%,
    rgba(0,0,0,0.32) 75%,
    rgba(0,0,0,0.00) 100%
  );
}
.shelf-outer::after{
  right:0;
  background:linear-gradient(
    to left,
    rgba(0,0,0,1) 0%,
    rgba(0,0,0,0.88) 20%,
    rgba(0,0,0,0.60) 45%,
    rgba(0,0,0,0.32) 75%,
    rgba(0,0,0,0.00) 100%
  );
}
/* Horizontal list of posters */
/* --- SHELF TRACK --- */
/* Add scroll-snapping and hide the scrollbar */
.shelf-track {
  display: grid;
  grid-auto-flow: column;
  gap: var(--shelf-gap);
  overflow-x: auto;
  overscroll-behavior-x: contain;
  -webkit-overflow-scrolling: touch;
  padding: 10px calc(16px + env(safe-area-inset-right)) 16px calc(16px + env(safe-area-inset-left));
  scroll-snap-type: x mandatory; /* Snap horizontally */
  scrollbar-width: none; /* Hide scrollbar for Firefox */
  cursor: grab;
  position: relative;
  z-index: 0;
}
.shelf-track::-webkit-scrollbar {
  display: none; /* Hide scrollbar for Chrome, Safari, Opera */
}
.shelf-track[role="list"] { list-style: none; }

.shelf-track.is-dragging {
  cursor: grabbing;
  user-select: none;
}

@media (pointer: fine) {
  .shelf-track {
    scroll-snap-type: none;
  }
}

/* --- POSTER --- */
/* Add snap alignment, transitions, and a transform origin */
.poster {
  position: relative;
  display: block;
  background: #1e2228;
  border: 1px solid #2a2f36;
  border-radius: var(--shelf-radius);
  overflow: hidden;
  aspect-ratio: 2 / 3;
  width: calc((100vw - (16px * 2) - (var(--shelf-gap) * 2)) / 3); /* ~3.0 visible on mobile */
  scroll-snap-align: center; /* Snap posters to the center */
  transform-origin: center center;
  filter: brightness(0.9);
  opacity: 0.8;
  /* Animate all the properties we change on the active state */
  transition: transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
              box-shadow 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
              border-color 0.35s ease,
              filter 0.35s ease,
              opacity 0.35s ease;
  z-index: 1; /* Default stacking level */
}


.preview-morph-tile {
  position: fixed;
  top: 0;
  left: 0;
  transform-origin: top left;
  pointer-events: none;
  z-index: 12000;
  background: #05060a;
  overflow: hidden;
  border: var(--preview-frame-border);
  border-radius: var(--preview-frame-radius);
  box-shadow: var(--preview-frame-shadow);
  transition:
    transform var(--preview-morph-duration) var(--preview-morph-ease),
    width var(--preview-morph-duration) var(--preview-morph-ease),
    height var(--preview-morph-duration) var(--preview-morph-ease),
    opacity 0.24s ease,
    border-radius var(--preview-morph-duration) var(--preview-morph-ease),
    box-shadow var(--preview-morph-duration) var(--preview-morph-ease),
    border-color var(--preview-morph-duration) var(--preview-morph-ease);
  will-change: transform, opacity, width, height, border-radius;
  backface-visibility: hidden;
  transform: translate3d(0,0,0);
}

.preview-morph-fill {
  position: absolute;
  inset: 0;
  background: #000;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  opacity: 1;
  transition: opacity var(--preview-morph-duration) var(--preview-morph-ease);
  backface-visibility: hidden;
}

.preview-morph-tile.is-fade-out {
  opacity: 0;
}

.preview-morph-fill.is-fade-out {
  opacity: 0;
}

.poster img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: inherit;
  -webkit-user-drag: none;
  user-select: none;
  pointer-events: none;
}

/* Style the active/centered poster to give it scale and depth */
/* Base active state: quiet red border, no neon glow */
.poster.is-active {
  border-width: 2px;
  border-style: solid;
  border-color: color-mix(in srgb, var(--brand) 55%, #2a2f36 45%);
  box-shadow: none;
  filter: brightness(1.0);
  opacity: 1;
  z-index: 2; /* Ensures the active card renders on top of its neighbors */
}

/* Row-activated neon: only when the shelf-track is active */
.shelf-track--active .poster.is-active {
  border-color: var(--brand);
  box-shadow: var(--brand-glow-shadow);
  filter: brightness(1.08);
  opacity: 1;
}

/* Make the poster label visible and styled */
.poster::after {
  content: attr(data-label);
  position: absolute;
  inset: auto 0 10px 0; /* Center the text horizontally near the bottom */
  color: #fff;
  font: 700 1.25rem/1 var(--font-ui);
  text-align: center;
  text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  opacity: 0.8;
  pointer-events: none; /* Ensure it doesn't interfere with clicks */
}
/* Desktop provisional */
@media (min-width:768px){ .poster{ width:140px; } }
/* Spacing tweaks */
.shelf--tight{ margin-top:8px; }
.content-pad--tight{ padding-bottom:8px; }
/* First shelf sits tighter under CTA */
.shelf--tight{ margin-top:8px; }

.hero-debug{
  display:none;
}

@media (min-width:1024px){
  /* Desktop: wider content and cinematic layout */
  .content-pad {
    max-width: 1280px;
    padding: 0 40px 24px 40px;
  }

  .hero-overlay-inline{
    padding-left: 40px !important;
    padding-right: 40px !important;
  }

  .hero-text {
    padding: 96px 0;
  }

  .shelf {
    margin: 0;
  }

  /* Desktop: pull Row A shelf (only) closer to the hero so that
     the top edge of the Row A posters aligns with the bottom edge
     of the hero video box. This moves Row A as a block without
     affecting Rows B and C. */
  .after-hero .shelf.shelf--tight {
    margin-top: 0.40rem;        /* Pills â†’ Row A label rhythm on desktop */
  }

  .hero-cta {
    max-width: 520px;
    margin-top: 0.40rem;
    margin-left: 0;
  }

  .btn {
    font-size: 0.95rem;
    padding: 0.50rem 0.80rem;
  }

  .poster {
    width: 200px;
  }

  /* Desktop: hero/video fills viewport width */
  .hero {
    width: 100vw;
    height: 80vh;
    max-height: 80vh;
    left: 0;
    transform: none;
    aspect-ratio: auto;
  }

    /* Desktop-only debug overlay grid */
  body.debug-layout .hero-debug{
    display:block;
    position:absolute;
    inset:0;
    z-index:3;
    pointer-events:none;
    background:transparent;
    background-image:
      linear-gradient(rgba(255,47,155,0.8) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,47,155,0.8) 1px, transparent 1px);
    background-size: calc(100%/6) calc(100%/4);
  }

  .after-hero{
    position:relative;
    z-index:3;
    margin-top: -16vh;   /* counter the extra hero height */
    background: transparent;
  }

  /* Desktop: add spacer padding so Row A cards sit on the same
     horizontal line as the bottom edge of the hero video box. */
  .after-hero{
    padding-top: 1.35rem; /* ZAQ TASK 03: lifted shelves so Row A aligns with hero text bottom */
  }


  .hero-overlay-inline{
    padding-left: 40px !important;
    padding-right: 40px !important;
    bottom:14vh !important;
    padding-bottom:0 !important;
  }

  .hero-synopsis{
    margin-bottom:0 !important;
  }


  .hero-gradient{
    background:linear-gradient(
      to top,
      rgba(0,0,0,0.98) 0%,
      rgba(0,0,0,0.92) 14%,
      rgba(0,0,0,0.78) 30%,
      rgba(0,0,0,0.56) 46%,
      rgba(0,0,0,0.32) 64%,
      rgba(0,0,0,0.16) 82%,
      rgba(0,0,0,0.00) 100%
    );
  }

  .hero-overlay-inline{
    left:0;
    padding-left:calc(var(--space-synopsis-pills) + env(safe-area-inset-left)) !important;
  }

  .shelf-title{
    margin-left:0;
    margin-bottom:0.32rem;
  }

  .shelf-track{
    padding: 24px 40px 24px 40px;
  }

  /* Desktop: remove extra top padding above Row A posters so their
     top edges can sit flush with the hero bottom line. */
  .after-hero .shelf.shelf--tight .shelf-track {
    padding-top: 24px;      /* align Row A posters with global desktop shelf padding */
  }
}


@media (min-width:1024px){
  /* Desktop: make iframe 16:9 and full viewport width, anchored to bottom of hero */
  .hero-video iframe{
    position:absolute;
    left:50%;
    top:50%;
    bottom:auto;
    right:auto;
    width:100vw;
    height:calc(100vw * 9 / 16);
    transform:translate(-50%, -50%);
  }
}


@media (min-width: 1024px) {
  /* Desktop-only debug outlines */

  body.debug-layout .hero {
    outline: 2px solid rgba(255, 0, 0, 0.8); /* red */
  }

  body.debug-layout .hero-overlay-wrap {
    outline: 2px solid rgba(0, 128, 255, 0.9); /* blue */
  }

  body.debug-layout .after-hero {
    outline: 2px solid rgba(0, 200, 120, 0.9); /* green */
    background-color: rgba(0, 200, 120, 0.06);
  }

  body.debug-layout .shelf {
    outline: 2px dashed rgba(255, 165, 0, 0.9); /* orange */
  }

  body.debug-layout .shelf-outer {
    outline: 2px solid rgba(255, 255, 0, 0.8); /* yellow */
    background-color: rgba(255, 255, 0, 0.04);
  }

  body.debug-layout .shelf-track {
    outline: 2px solid rgba(186, 85, 211, 0.9); /* purple */
    background-color: rgba(186, 85, 211, 0.04);
  }

  body.debug-layout .poster {
    outline: 2px solid rgba(0, 255, 255, 0.9); /* cyan */
  }

  body.debug-layout .poster.is-active {
    outline: 3px solid rgba(255, 255, 255, 0.95); /* white, stronger */
  }
}


@media (min-width: 1024px) {
  /* Desktop-only debug outlines: hero text + inner content container */
  body.debug-layout .hero-overlay-inline {
    outline: 2px solid rgba(255, 105, 180, 0.9); /* pink */
  }

  body.debug-layout .content-pad {
    outline: 2px solid rgba(173, 216, 230, 0.9); /* light blue */
  }
}

:root {
  /* Hero + Row A spacing tokens, aligned to a 4px-based grid (comments only) */
  --space-chip-meta: 0.5rem;      /* â‰ˆ 8px  = 2 Ã— 4px  (Chip â†’ Meta) */
  --space-synopsis-pills: 2.20rem;/* â‰ˆ 35px â‰ˆ 9 Ã— 4px (Synopsis â†’ Pills) */
  --space-pills-rowa: 0.40rem;    /* â‰ˆ 6px  â‰ˆ 1.5 Ã— 4px (Pills â†’ Row A label) */
  --space-rowa-divider: 0.20rem;  /* â‰ˆ 3px  â‰ˆ 0.75 Ã— 4px (Row A label â†’ divider) */

  /* ZAQ â€“ shelf label vertical offsets */
  --shelf-title-shift-mobile: 2rem;    /* shift labels into gap below divider on mobile/tablet */
  --shelf-title-shift-desktop: 2.25rem;/* slightly larger shift for desktop gap */
}

/* ZAQ â€“ desktop-only vertical rhythm for hero + Row A */
@media (min-width: 1024px) {
  .title-chip {
    margin-bottom: var(--space-chip-meta);       /* Chip â†’ Meta */
  }

  .hero-cta {
    margin-top: var(--space-synopsis-pills);     /* Synopsis â†’ Pills */
  }

  .shelf.shelf--tight {
    margin-top: var(--space-pills-rowa);         /* Pills â†’ Row A Label */
  }

  .shelf-title {
    margin-bottom: var(--space-rowa-divider);    /* Row A Label â†’ Divider */
    transform: translateY(var(--shelf-title-shift-desktop));
  }
}

  /* =============================
     Preview Overlay (Static Layout)
     ============================= */
  .preview-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, rgba(0,0,0,0.80), rgba(0,0,0,0.95));
    z-index: 999;
    padding: 16px;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity var(--preview-morph-duration) var(--preview-morph-ease), visibility 0s linear var(--preview-morph-duration);
  }

  /* Future: when we add JS, weâ€™ll toggle this class */
  .preview-overlay.is-visible {
    z-index: 9999;
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transition: opacity var(--preview-morph-duration) var(--preview-morph-ease);
  }

  .preview-card {
    width: 100%;
    max-width: 960px;
    max-height: 90vh;
    background: #05060a;
    border-radius: var(--preview-frame-radius);
    border: var(--preview-frame-border);
    box-shadow: var(--preview-frame-shadow);
    overflow: hidden;
    display: grid;
    grid-template-rows: auto 1fr;
    position: relative;
    opacity: 0;
    transition:
      transform var(--preview-morph-duration) var(--preview-morph-ease),
      opacity var(--preview-morph-duration) var(--preview-morph-ease);
  }

  .preview-card.is-active {
    opacity: 1;
  }

  .preview-card.is-hidden {
    opacity: 0;
    pointer-events: none;
  }

  .preview-close-btn {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 36px;
    height: 36px;
    display: inline-grid;
    place-items: center;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(0,0,0,0.55);
    color: #fff;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
  }

  .preview-close-btn:hover {
    background: rgba(255,255,255,0.10);
  }

  .preview-media {
    position: relative;
    background: #000;
    aspect-ratio: 16 / 9;
  }

  .preview-media-placeholder {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(circle at top, rgba(255,255,255,0.10), transparent 55%),
      linear-gradient(135deg, #222632, #11131a);
  }

  .preview-info {
    padding: 16px 18px 18px 18px;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 12px;
  }

  .preview-header {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .preview-title {
    font-family: var(--font-display);
    font-size: 1.2rem;
    font-weight: 800;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    margin: 0;
  }

  .preview-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    font-size: 0.78rem;
    color: var(--muted);
  }

  .preview-runtime {
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    font-weight: 600;
  }

  .preview-tags {
    opacity: 0.9;
  }

  .preview-body {
    font-size: 0.88rem;
    color: var(--muted);
    overflow: auto;
  }

  .preview-description {
    margin: 0;
  }

  .preview-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: flex-start;
  }

  .preview-play-button,
  .preview-details-button {
    appearance: none;
    border-radius: 999px;
    padding: 8px 14px;
    font: 700 0.85rem/1 var(--font-ui);
    cursor: pointer;
    border: 0;
    transition: background 0.16s ease, transform 0.12s ease, box-shadow 0.16s ease;
  }

  .preview-play-button {
    background: #fff;
    color: #000;
    box-shadow: 0 12px 32px rgba(0,0,0,0.55);
  }

  .preview-play-button:hover {
    background: #f0f0f0;
    transform: translateY(1px);
  }

  .preview-details-button {
    background: rgba(255,255,255,0.06);
    color: #eaeaf0;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.15);
  }

  .preview-details-button:hover {
    background: rgba(255,255,255,0.10);
  }

  @media (max-width: 640px) {
    .preview-card {
      max-width: 100%;
      border-radius: var(--preview-frame-radius);
      max-height: 100vh;
    }

    .preview-info {
      padding: 14px 14px 16px 14px;
    }
  }

  /* =============================
     Poster Preview Button (A1 only)
     ============================= */
  .poster-preview-button {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 14px;
    font-size: 0.75rem;
    font-family: var(--font-ui);
    font-weight: 700;
    text-transform: uppercase;
    border-radius: 999px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.25);
    color: #fff;
    backdrop-filter: blur(6px);
    cursor: pointer;
    transition: opacity 0.25s ease, transform 0.25s ease;
    opacity: 1;            /* always visible for now */
    pointer-events: auto;  /* clickable */
  }

  .poster-preview-button:hover {
    background: rgba(255,255,255,0.20);
    transform: translateX(-50%) scale(1.05);
  }

</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
  <header class="nav-bar" role="navigation" aria-label="Main">
    <div class="nav-inner">
      <a class="brand" href="/" aria-label="Home">SanchezNinjah</a>
      <nav class="nav-links" aria-label="Primary">
        <a class="nav-link nav-link--active" href="#hero" aria-label="Go to Film section" aria-current="page">Film</a>
        <a class="nav-link" href="#photography" aria-label="Go to Photography section">Photography</a>
        <a class="nav-link" href="#social-media" aria-label="Go to Social Media section">Social Media</a>
        <a class="nav-link" href="#side-quests" aria-label="Go to Side Quests section">Side Quests</a>
        <a class="nav-link" href="#about" aria-label="Go to About section">About</a>
        <a class="nav-link" href="#contact" aria-label="Go to Contact section">Contact</a>
      </nav>
      <div class="nav-actions">
        <button class="icon-btn" aria-label="Search">
          <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true"><path d="M10.5 3a7.5 7.5 0 015.92 12.2l3.69 3.69-1.42 1.42-3.69-3.69A7.5 7.5 0 1110.5 3zm0 2a5.5 5.5 5.5 0 100 11 5.5 5.5 0 000-11z"/></svg>
        </button>
        <button class="icon-btn" aria-label="Notifications">
          <span class="dot" aria-hidden="true"></span>
          <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a4 4 0 00-4 4v1.1C6.2 8 5 9.7 5 11.6V17l-1.5 1.5v1h17v-1L19 17v-5.4c0-1.9-1.2-3.6-3-4.5V6a4 4 0 00-4-4zm0 20a3 3 0 01-3-3h6a3 3 0 01-3 3z"/></svg>
        </button>
        <button class="icon-btn" id="debugToggleButton" type="button" aria-label="Toggle layout debug" aria-pressed="false">Debug</button>
      </div>
    </div>
  </header>
  <main>
<section class="hero" id="hero">
  <div class="hero-video">
    <iframe
      id="hero-yt"
      title="Hero trailer"
      src="https://www.youtube.com/embed/VBdaOkpLe_o?start=12&autoplay=1&mute=1&controls=0&playsinline=1&loop=1&modestbranding=1&rel=0&enablejsapi=1&playlist=VBdaOkpLe_o"
      allow="autoplay; encrypted-media"
      allowfullscreen
    ></iframe>
    <div class="hero-debug" aria-hidden="true"></div>
  </div>

  <!-- Hero gradient: bottom â†’ top -->
  <div class="hero-gradient" aria-hidden="true"></div>

  <!-- Overlay area locked to viewport edges -->
  <div class="hero-overlay-wrap"
       style="position:absolute;top:0;bottom:0;
              left:calc((100% - 100vw)/2);
              right:calc((100% - 100vw)/2);
              z-index:2;display:flex;flex-direction:column;
              justify-content:flex-end;pointer-events:none;overflow:hidden;">
    <div class="hero-overlay-inline"
         style="pointer-events:auto;position:absolute;bottom:0;left:0;
                max-width:720px;color:#fff;text-align:left;
                padding:12px calc(16px + env(safe-area-inset-right)) 0 calc(16px + env(safe-area-inset-left));
                text-shadow:0 1px 3px rgba(0,0,0,.5);
                background:transparent;border-radius:12px 12px 0 0;">
<div class="title-chip" role="heading" aria-level="1">
  <span class="title-chip-text">Sanchez Ninjah</span>
</div>

<p id="meta-line" style="margin:0 0 .14rem;color:var(--brand);
                font-size:clamp(.78rem,1.6vw,.95rem);
                font-weight:700;letter-spacing:.08em;text-transform:uppercase;">
  New Release | Thriller, Sci-Fi | 2024
</p>

      <p class="hero-synopsis" style="margin:0;color:#e5e7eb;
                font-size:clamp(.95rem,2.2vw,1.15rem);line-height:1.55;
                display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;
                overflow:hidden;">
        As a rogue AI network threatens global collapse, a disgraced former agent is called
        back into the field for one last, impossible mission to save humanity.
      </p>
      <div class="hero-cta">
      <!-- Play Now -->
      <button type="button" class="btn btn--solid" onclick="console.log('Play trailer')">
        <svg aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor">
          <path d="M6 4l10 6-10 6V4z"/>
        </svg>
        <span>Play Now</span>
      </button>

      <!-- Details -->
      <button type="button" class="btn btn--ghost" onclick="console.log('More info')">
        <svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M13 16h-1v-4h-1m1-4h.01"/>
          <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
        <span>Details</span>
      </button>
    </div>
    </div>
  </div>

  <button class="mute-btn" type="button" aria-pressed="true" onclick="toggleMute()" aria-label="Mute or unmute">ðŸ”‡</button>
</section>
<!-- This wrapper div was limiting the width and causing the pink background to leak. -->
<!-- OLD: <div class="wrap wrap--flush"> -->
<section class="after-hero" aria-label="Actions">
  <!-- Use a new inner wrapper to apply max-width and centering for content -->

  <!-- Row A moved inside after-hero -->
  <section class="shelf shelf--tight" aria-labelledby="row-a-title">
    <div class="content-pad">
      <h2 id="row-a-title" class="shelf-title">Row A</h2>
      <div class="shelf-divider" aria-hidden="true"></div>
    </div>
    <div class="shelf-outer">
      <div class="shelf-track" data-row="A" role="list" aria-label="Row A posters">
        <a class="poster" role="listitem" aria-label="A1" data-label="A1" data-title="TBD Title A1" data-description="TBD Description A1" data-runtime="TBD Runtime A1" data-tags="TBD Tags A1" data-youtube-url="TBD YouTube URL A1" data-poster-vert="images/poster-vert-A1.png" data-poster-wide="images/poster-wide-A1.png" data-morph-id="morph-01"><img src="images/poster-vert-A1.png" alt="Sanchez Ninjah A1 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A2" data-label="A2" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A2.png" data-poster-wide="images/poster-wide-A2.png" data-morph-id="morph-02"><img src="images/poster-vert-A2.png" alt="A2 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A3" data-label="A3" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A3.png" data-poster-wide="images/poster-wide-A3.png" data-morph-id="morph-03"><img src="images/poster-vert-A3.png" alt="A3 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A4" data-label="A4" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A4.png" data-poster-wide="images/poster-wide-A4.png" data-morph-id="morph-04"><img src="images/poster-vert-A4.png" alt="A4 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A5" data-label="A5" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A5.png" data-poster-wide="images/poster-wide-A5.png" data-morph-id="morph-05"><img src="images/poster-vert-A5.png" alt="A5 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A6" data-label="A6" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A6.png" data-poster-wide="images/poster-wide-A6.png" data-morph-id="morph-06"><img src="images/poster-vert-A6.png" alt="A6 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A7" data-label="A7" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A7.png" data-poster-wide="images/poster-wide-A7.png" data-morph-id="morph-07"><img src="images/poster-vert-A7.png" alt="A7 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A8" data-label="A8" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A8.png" data-poster-wide="images/poster-wide-A8.png" data-morph-id="morph-08"><img src="images/poster-vert-A8.png" alt="A8 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A9" data-label="A9" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A9.png" data-poster-wide="images/poster-wide-A9.png" data-morph-id="morph-09"><img src="images/poster-vert-A9.png" alt="A9 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A10" data-label="A10" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A10.png" data-poster-wide="images/poster-wide-A10.png" data-morph-id="morph-10"><img src="images/poster-vert-A10.png" alt="A10 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      </div>
    </div>
  </section>
</section>
<!-- Shelves: titles in container, cards full-bleed -->

<section class="shelf" aria-labelledby="row-b-title">
  <div class="content-pad">
    <h2 id="row-b-title" class="shelf-title">Row B</h2>
    <div class="shelf-divider" aria-hidden="true"></div>
  </div>
  <div class="shelf-outer">
    <div class="shelf-track" data-row="B" role="list" aria-label="Row B posters">
      <a class="poster" role="listitem" aria-label="B1" data-label="B1" data-title="TBD Title B1" data-description="TBD Description B1" data-runtime="TBD Runtime B1" data-tags="TBD Tags B1" data-youtube-url="TBD YouTube URL B1" data-poster-vert="images/poster-vert-A1.png" data-poster-wide="images/poster-wide-A1.png" data-morph-id="morph-11"><img src="images/poster-vert-A1.png" alt="B1 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B2" data-label="B2" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A2.png" data-poster-wide="images/poster-wide-A2.png" data-morph-id="morph-12"><img src="images/poster-vert-A2.png" alt="B2 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B3" data-label="B3" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A3.png" data-poster-wide="images/poster-wide-A3.png" data-morph-id="morph-13"><img src="images/poster-vert-A3.png" alt="B3 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B4" data-label="B4" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A4.png" data-poster-wide="images/poster-wide-A4.png" data-morph-id="morph-14"><img src="images/poster-vert-A4.png" alt="B4 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B5" data-label="B5" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A5.png" data-poster-wide="images/poster-wide-A5.png" data-morph-id="morph-15"><img src="images/poster-vert-A5.png" alt="B5 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B6" data-label="B6" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A6.png" data-poster-wide="images/poster-wide-A6.png" data-morph-id="morph-16"><img src="images/poster-vert-A6.png" alt="B6 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B7" data-label="B7" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A7.png" data-poster-wide="images/poster-wide-A7.png" data-morph-id="morph-17"><img src="images/poster-vert-A7.png" alt="B7 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B8" data-label="B8" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A8.png" data-poster-wide="images/poster-wide-A8.png" data-morph-id="morph-18"><img src="images/poster-vert-A8.png" alt="B8 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B9" data-label="B9" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A9.png" data-poster-wide="images/poster-wide-A9.png" data-morph-id="morph-19"><img src="images/poster-vert-A9.png" alt="B9 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B10" data-label="B10" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A10.png" data-poster-wide="images/poster-wide-A10.png" data-morph-id="morph-20"><img src="images/poster-vert-A10.png" alt="B10 poster"><button class="poster-preview-button" type="button">Preview</button></a>
    </div>
  </div>
</section>

<section class="shelf" aria-labelledby="row-c-title">
  <div class="content-pad">
    <h2 id="row-c-title" class="shelf-title">Row C</h2>
    <div class="shelf-divider" aria-hidden="true"></div>
  </div>
  <div class="shelf-outer">
    <div class="shelf-track" data-row="C" role="list" aria-label="Row C posters">
      <a class="poster" role="listitem" aria-label="C1" data-label="C1" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C1.png" data-poster-wide="images/poster-wide-C1.png"></a>
      <a class="poster" role="listitem" aria-label="C2" data-label="C2" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C2.png" data-poster-wide="images/poster-wide-C2.png"></a>
      <a class="poster" role="listitem" aria-label="C3" data-label="C3" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C3.png" data-poster-wide="images/poster-wide-C3.png"></a>
      <a class="poster" role="listitem" aria-label="C4" data-label="C4" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C4.png" data-poster-wide="images/poster-wide-C4.png"></a>
      <a class="poster" role="listitem" aria-label="C5" data-label="C5" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C5.png" data-poster-wide="images/poster-wide-C5.png"></a>
      <a class="poster" role="listitem" aria-label="C6" data-label="C6" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C6.png" data-poster-wide="images/poster-wide-C6.png"></a>
      <a class="poster" role="listitem" aria-label="C7" data-label="C7" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C7.png" data-poster-wide="images/poster-wide-C7.png"></a>
      <a class="poster" role="listitem" aria-label="C8" data-label="C8" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C8.png" data-poster-wide="images/poster-wide-C8.png"></a>
      <a class="poster" role="listitem" aria-label="C9" data-label="C9" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C9.png" data-poster-wide="images/poster-wide-C9.png"></a>
      <a class="poster" role="listitem" aria-label="C10" data-label="C10" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C10.png" data-poster-wide="images/poster-wide-C10.png"></a>
    </div>
  </div>
</section>
<!-- OLD: </div> -->

  </main>

  <footer>
    Â© <span id="y"></span> Rawoul
    <nav class="footer-nav" aria-label="Footer navigation">
      <a class="footer-nav-link footer-nav-link--active" href="#hero" aria-label="Go to Film section">Film</a>
      <a class="footer-nav-link" href="#photography" aria-label="Go to Photography section">Photography</a>
      <a class="footer-nav-link" href="#social-media" aria-label="Go to Social Media section">Social Media</a>
      <a class="footer-nav-link" href="#side-quests" aria-label="Go to Side Quests section">Side Quests</a>
      <a class="footer-nav-link" href="#about" aria-label="Go to About section">About</a>
      <a class="footer-nav-link" href="#contact" aria-label="Go to Contact section">Contact</a>
    </nav>
  </footer>
  <script>document.getElementById('y').textContent = new Date().getFullYear();</script>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
  // Changed alerts to console.log as alerts break the canvas environment.
  let ytPlayer, isMuted = true;
  function onYouTubeIframeAPIReady(){
    ytPlayer = new YT.Player('hero-yt', {
      events: { onReady: e => { e.target.mute(); e.target.playVideo(); } }
    });
  }
  function toggleMute(){
    if(!ytPlayer) return;
    if(isMuted){ ytPlayer.unMute(); isMuted=false; document.querySelector('.mute-btn').textContent='ðŸ”Š'; document.querySelector('.mute-btn').setAttribute('aria-pressed','false'); }
    else{ ytPlayer.mute(); isMuted=true; document.querySelector('.mute-btn').textContent='ðŸ”‡'; document.querySelector('.mute-btn').setAttribute('aria-pressed','true'); }
  }
</script>
<script>
  // Make the CTA row 1/3 shorter than its own available width
  (function(){
    function alignCta(){
      const cta = document.querySelector('.hero-cta');
      if(!cta || !cta.parentElement) return;

      // Use the parentâ€™s current width as the stable base
      const base = cta.parentElement.getBoundingClientRect().width;

      // Target = 67% of that base (i.e., 1/3 shorter)
      const target = Math.round(base * 0.67);

      // Clamp to keep both pills on one line
      const clamped = Math.max(200, Math.min(target, 420));

      cta.style.width = clamped + 'px';
    }
    window.addEventListener('load', alignCta);
    window.addEventListener('resize', alignCta);
    window.addEventListener('orientationchange', alignCta);
  })();
</script>
<script>
  // Press "g" to toggle pink gap debug
  document.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'g') document.body.classList.toggle('debug-gap');
  });
  // start disabled
  // document.body.classList.add('debug-gap');
</script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Number of original sets to clone on each side for the infinite effect
    const CLONE_COUNT = 4;
    const RECENTER_DURATION = 1800; // ms, slow cinematic glide
    const activeScrollAnimations = new Map();
    let lastActiveTrack = null;

    function cancelScrollAnimation(track) {
      if (!track) return;
      const anim = activeScrollAnimations.get(track);
      if (anim && typeof anim.frameId === 'number') {
        cancelAnimationFrame(anim.frameId);
      }
      activeScrollAnimations.delete(track);
      track.__scrollAnimating = false;
    }

    function animateScrollLeftSlow(track, target, durationMs) {
      if (!track || typeof target !== 'number' || !isFinite(target)) return;

      cancelScrollAnimation(track);

      const start = track.scrollLeft;
      const distance = target - start;

      if (distance === 0 || durationMs <= 0) {
        track.scrollLeft = target;
        return;
      }

      const startTime = performance.now();
      track.__scrollAnimating = true;

      function easeInOutCubic(t) {
        // Extra gentle ease-in-out with zero velocity and acceleration at ends
        // "smootherstep": t^3 * (t * (6t - 15) + 10)
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * t * (t * (6 * t - 15) + 10);
      }

      function step(now) {
        const elapsed = now - startTime;
        let t = elapsed / durationMs;
        if (t < 0) t = 0;
        if (t > 1) t = 1;

        const eased = easeInOutCubic(t);
        track.scrollLeft = start + distance * eased;

        const currentAnim = activeScrollAnimations.get(track);
        if (t < 1 && currentAnim && currentAnim.step === step) {
          const frameId = requestAnimationFrame(step);
          currentAnim.frameId = frameId;
        } else {
          track.scrollLeft = target;
          activeScrollAnimations.delete(track);
          track.__scrollAnimating = false;
        }
      }

      const frameId = requestAnimationFrame(step);
      activeScrollAnimations.set(track, { frameId, step });
    }

    function recenterTrackActivePoster(track) {
      if (!track) return;
      const activePoster = track.querySelector('.poster.is-active');
      if (!activePoster) return;

      const trackRect = track.getBoundingClientRect();
      const posterRect = activePoster.getBoundingClientRect();

      // Center the active poster to the viewport center, so all rows share the same screen center
      const viewportCenterX = window.innerWidth / 2;
      const posterCenterOffset = activePoster.offsetLeft + (posterRect.width / 2);
      const viewportCenterRelativeToTrack = viewportCenterX - trackRect.left;
      const target = posterCenterOffset - viewportCenterRelativeToTrack;

      animateScrollLeftSlow(track, target, RECENTER_DURATION);
    }

    const shelfTracks = Array.from(document.querySelectorAll('.shelf-track'));

    function recenterAllOtherTracks(currentTrack) {
      if (!shelfTracks.length) return;
      for (const track of shelfTracks) {
        if (track === currentTrack) continue;
        if (track.classList.contains('is-dragging')) continue;
        cancelScrollAnimation(track);
        recenterTrackActivePoster(track);
      }
    }

    let windowScrollRaf = null;

    function updateActiveTrackFromWindowScroll() {
      if (!shelfTracks.length) return;

      let closestTrack = null;
      let smallestDistance = Infinity;
      const viewportCenterY = window.innerHeight / 2;

      for (const track of shelfTracks) {
        const rect = track.getBoundingClientRect();
        const trackCenterY = rect.top + rect.height / 2;
        const distance = Math.abs(trackCenterY - viewportCenterY);

        if (distance < smallestDistance) {
          smallestDistance = distance;
          closestTrack = track;
        }
      }

      if (!closestTrack) return;

      const previousActiveTrack = lastActiveTrack;

      if (previousActiveTrack && previousActiveTrack !== closestTrack) {
        previousActiveTrack.classList.remove('shelf-track--active');
      }
      closestTrack.classList.add('shelf-track--active');
      lastActiveTrack = closestTrack;

      if (previousActiveTrack !== closestTrack) {
        recenterTrackActivePoster(closestTrack);
        recenterAllOtherTracks(closestTrack);
      }
    }

    window.addEventListener('scroll', () => {
      if (windowScrollRaf !== null) return;
      windowScrollRaf = requestAnimationFrame(() => {
        windowScrollRaf = null;
        updateActiveTrackFromWindowScroll();
      });
    }, { passive: true });

    document.querySelectorAll('.shelf-track').forEach(track => {
      const originalPosters = Array.from(track.children);
      if (originalPosters.length === 0) return;

      // --- 1. CLONE POSTERS for infinite effect ---
      const fragment = document.createDocumentFragment();
      originalPosters.forEach(poster => fragment.appendChild(poster.cloneNode(true)));

      for (let i = 0; i < CLONE_COUNT; i++) {
        track.prepend(fragment.cloneNode(true));
        track.append(fragment.cloneNode(true));
      }

      // --- 2. SET INITIAL SCROLL POSITION ---
      // We want to start at the first "real" card, not the clones.
      const initialPosterIndex = originalPosters.length * CLONE_COUNT;
      const initialPoster = track.children[initialPosterIndex];
      if (!initialPoster) return;

      // Calculate the position to perfectly center the first real poster on load
      const trackRect = track.getBoundingClientRect();
      const initialPosterRect = initialPoster.getBoundingClientRect();
      track.scrollLeft = initialPoster.offsetLeft - (trackRect.width / 2) + (initialPosterRect.width / 2);

      // --- 3. Continuous magnifier scaling + active card ---
      function updateScalesAndActive() {
        const trackRect = track.getBoundingClientRect();
        const trackCenterX = trackRect.left + trackRect.width / 2;

        const maxScale = 1.12; // largest at center
        const minScale = 0.78; // smallest far away

        let closestPoster = null;
        let smallestDistance = Infinity;
        const halfWidth = trackRect.width / 2 || 1; // avoid divide by zero
        const maxZ = 1000; // base for stacking order

        for (const poster of track.children) {
          const rect = poster.getBoundingClientRect();
          const posterCenterX = rect.left + rect.width / 2;

          const distance = Math.abs(trackCenterX - posterCenterX);

          const t = Math.min(distance / halfWidth, 1); // 0 at center, 1 at far edge

          const scale = maxScale - (maxScale - minScale) * t;
          poster.style.transform = 'scale(' + scale.toFixed(3) + ')';

          // Depth-based z-index: nearer to center = higher z-index
          const depth = 1 - t; // 1 at center, 0 at far edge
          const z = Math.round(depth * 100) + 1;
          poster.style.zIndex = String(z);

          if (distance < smallestDistance) {
            smallestDistance = distance;
            closestPoster = poster;
          }
        }

        if (closestPoster) {
          for (const poster of track.children) {
            if (poster === closestPoster) {
              poster.classList.add('is-active');
              // Ensure active card always sits on top of neighbors
              poster.style.zIndex = String(maxZ);
            } else {
              poster.classList.remove('is-active');
            }
          }
        }
      }

      let scrollEndTimeout = null;

      const handleScroll = () => {
        const isAnimating = !!track.__scrollAnimating;

        // Always keep the magnifier / active-card state in sync
        updateScalesAndActive();

        if (!isAnimating) {
          const previousActiveTrack = lastActiveTrack;

          // Toggle the active shelf-track for row-scoped neon
          if (previousActiveTrack && previousActiveTrack !== track) {
            previousActiveTrack.classList.remove('shelf-track--active');
          }
          track.classList.add('shelf-track--active');
          lastActiveTrack = track;

          if (previousActiveTrack !== track) {
            recenterAllOtherTracks(track);
          }

          // Same-row behavior: when the user scrolls away and then stops,
          // gently recenter the active card in this row.
          if (scrollEndTimeout) {
            clearTimeout(scrollEndTimeout);
          }
          scrollEndTimeout = setTimeout(() => {
            if (!track.__scrollAnimating) {
              recenterTrackActivePoster(track);
            }
          }, 120);
        }
      };

      track.addEventListener('scroll', handleScroll);

      // Ensure the first magnifier run happens after scrollLeft/layout settle
      requestAnimationFrame(updateScalesAndActive);

      // Recalculate magnifier whenever the viewport size changes
      window.addEventListener('resize', () => {
        requestAnimationFrame(updateScalesAndActive);
      });

      // Desktop-only grab-to-drag behavior
      if (window.matchMedia && window.matchMedia('(pointer: fine)').matches) {
        let isDragging = false;
        let startX;
        let startScrollLeft;

        track.addEventListener('mousedown', (event) => {
          if (event.button !== 0) return; // left button only
          cancelScrollAnimation(track);
          isDragging = true;
          track.classList.add('is-dragging');
          startX = event.pageX - track.offsetLeft;
          startScrollLeft = track.scrollLeft;
        });

        track.addEventListener('mousemove', (event) => {
          if (!isDragging) return;
          event.preventDefault();
          const x = event.pageX - track.offsetLeft;
          const walk = x - startX;
          track.scrollLeft = startScrollLeft - walk;
        });

        const stopDragging = () => {
          if (!isDragging) return;
          isDragging = false;
          track.classList.remove('is-dragging');
        };

        track.addEventListener('mouseleave', stopDragging);
        track.addEventListener('mouseup', stopDragging);
      }

      // Cancel any ongoing recenter animation when the user manually scrolls
      track.addEventListener('wheel', (event) => {
        if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
          cancelScrollAnimation(track);
        }
      }, { passive: true });

      track.addEventListener('touchstart', () => {
        cancelScrollAnimation(track);
      }, { passive: true });
    });
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    var debugButton = document.getElementById('debugToggleButton');
    if (!debugButton) return;

    function syncDebugButtonState() {
      var isActive = document.body.classList.contains('debug-layout');
      debugButton.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    }

    syncDebugButtonState();

    debugButton.addEventListener('click', function () {
      document.body.classList.toggle('debug-layout');
      syncDebugButtonState();
    });
  });
</script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      
      const morphCards = Array.from(document.querySelectorAll('.poster[data-morph-id]'));

      // Note: shelves clone posters for infinite scrolling. We use event delegation
      // and per-card data-morph-id so both originals and clones open correctly.
const previewOverlay = document.querySelector('.preview-overlay');
      const previewCloseButton = document.querySelector('.preview-close-btn');
      const previewTitleEl = document.querySelector('.preview-title');
      const previewRuntimeEl = document.querySelector('.preview-runtime');
      const previewTagsEl = document.querySelector('.preview-tags');
      const previewDescriptionEl = document.querySelector('.preview-description');

      if (
        !morphCards.length ||
        !previewOverlay ||
        !previewCloseButton ||
        !previewTitleEl ||
        !previewRuntimeEl ||
        !previewTagsEl ||
        !previewDescriptionEl
      ) {
        return;

      // ZAQ TASK 1.9: Resume hero video on preview close with soft fades (visual + audio).
      let heroAudioFadeInterval = null;
      let heroPausedTime = null;

      function cancelHeroAudioFade() {
        if (heroAudioFadeInterval !== null) {
          clearInterval(heroAudioFadeInterval);
          heroAudioFadeInterval = null;
        }
      }

      function resumeHeroAfterPreviewClose() {
        // Run only after preview closes successfully.
        if (typeof ytPlayer === 'undefined' || !ytPlayer) return;

        const heroVisual = document.querySelector('.hero-video');
        if (heroVisual) {
          // Immediately fade out, then fade back in over CSS transition duration.
          heroVisual.classList.add('is-hero-fadeout');
        }

        cancelHeroAudioFade();

        try {
          // Ensure playback resumes.
          let currentHeroTime = null;
          try {
            if (typeof ytPlayer.getCurrentTime === 'function') {
              const ct = ytPlayer.getCurrentTime();
              if (typeof ct === 'number' && isFinite(ct)) currentHeroTime = ct;
            }
          } catch (_) {}

          const hasPausedTime =
            (typeof heroPausedTime === 'number' && isFinite(heroPausedTime) && heroPausedTime > 0.25);
          const hasCurrentTime =
            (typeof currentHeroTime === 'number' && isFinite(currentHeroTime));

          const needsSeekBack =
            hasPausedTime &&
            hasCurrentTime &&
            (currentHeroTime < 0.5 || Math.abs(currentHeroTime - heroPausedTime) > 2.0);

          if (needsSeekBack && typeof ytPlayer.seekTo === 'function') {
            try { ytPlayer.seekTo(heroPausedTime, true); } catch (_) {}
          }

          if (typeof ytPlayer.playVideo === 'function') {
            ytPlayer.playVideo();
          }

          // Respect global mute state.
          if (typeof isMuted !== 'undefined' && isMuted) {
            if (typeof ytPlayer.mute === 'function') ytPlayer.mute();
          } else {
            // Smooth audio ramp up using volume steps.
            let targetVolume = 100;
            try {
              if (typeof ytPlayer.getVolume === 'function') {
                const v = ytPlayer.getVolume();
                if (typeof v === 'number' && isFinite(v)) targetVolume = v;
              }
            } catch (_) {}

            const startVolume = 1;
            const durationMs = 1400; // ~1.2â€“1.6s
            const stepMs = 100;
            const steps = Math.max(1, Math.round(durationMs / stepMs));
            let step = 0;

            try {
              if (typeof ytPlayer.setVolume === 'function') ytPlayer.setVolume(startVolume);
            } catch (_) {}

            try {
              if (typeof ytPlayer.unMute === 'function') ytPlayer.unMute();
            } catch (_) {}

            heroAudioFadeInterval = setInterval(() => {
              step += 1;
              const t = Math.min(step / steps, 1);
              const vol = Math.round(startVolume + (targetVolume - startVolume) * t);
              try {
                if (typeof ytPlayer.setVolume === 'function') ytPlayer.setVolume(vol);
              } catch (_) {}
              if (t >= 1) {
                cancelHeroAudioFade();
              }
            }, stepMs);
          }
        } catch (_) {}

        if (heroVisual) {
          requestAnimationFrame(() => {
            // Ensure the "faded out" state is applied before transitioning to visible.
            heroVisual.offsetHeight;
            heroVisual.classList.remove('is-hero-fadeout');
          });
        }
      }

      }

      const MORPH_DURATION = 520;
      const PREVIEW_EASING = 'cubic-bezier(0.25, 0.1, 0.25, 1)';
      const FILL_FADE_DURATION = 220;
      let lastOpenedCard = null;

      let scrollLockState = null;

      function lockScroll() {
        if (scrollLockState) return;
        const docEl = document.documentElement;
        const body = document.body;

        scrollLockState = {
          htmlOverflow: docEl.style.overflow,
          bodyOverflow: body.style.overflow,
          bodyPaddingRight: body.style.paddingRight
        };

        const supportsStableScrollbarGutter =
          window.CSS && typeof CSS.supports === 'function' && CSS.supports('scrollbar-gutter: stable');

        if (!supportsStableScrollbarGutter) {
          const scrollbarWidth = window.innerWidth - docEl.clientWidth;
          if (scrollbarWidth > 0) {
            const computedPaddingRight = window.getComputedStyle(body).paddingRight;
            const currentPadding = parseFloat(computedPaddingRight) || 0;
            body.style.paddingRight = `${currentPadding + scrollbarWidth}px`;
          }
        }

        docEl.style.overflow = 'hidden';
        body.style.overflow = 'hidden';
      }

      function unlockScroll() {
        if (!scrollLockState) return;
        const docEl = document.documentElement;
        const body = document.body;

        docEl.style.overflow = scrollLockState.htmlOverflow;
        body.style.overflow = scrollLockState.bodyOverflow;
        body.style.paddingRight = scrollLockState.bodyPaddingRight;

        scrollLockState = null;
      }
      let activeMorphTile = null;

      let currentMorphDuration = MORPH_DURATION;
      let currentMorphEasing = PREVIEW_EASING;

      const OPEN_MORPH_PROFILES = [
        { id: 'morph-01', name: 'Straight Zoom', kf: 'straight', duration: 520, easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)' },
        { id: 'morph-02', name: 'Arc Sweep', kf: 'arcSweep', duration: 520, easing: 'cubic-bezier(0.18, 0.80, 0.20, 1)', arcX: 46, arcY: -34 },
        { id: 'morph-03', name: 'Overshoot Snap', kf: 'overshootSnap', duration: 480, easing: 'cubic-bezier(0.16, 1, 0.3, 1)', overshoot: 18 },
        { id: 'morph-04', name: 'Spring Elastic', kf: 'springElastic', duration: 720, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', bounce: 3 },
        { id: 'morph-05', name: 'Hinge Flip', kf: 'hingeFlip', duration: 520, easing: 'cubic-bezier(0.20, 0.90, 0.20, 1)', tilt: 10 },
        { id: 'morph-06', name: 'Yaw Rotate', kf: 'yawRotate', duration: 520, easing: 'cubic-bezier(0.20, 0.90, 0.20, 1)', yaw: 14 },
        { id: 'morph-07', name: 'Pop In Place', kf: 'popInPlace', duration: 520, easing: 'cubic-bezier(0.12, 0.90, 0.10, 1)' },
        { id: 'morph-08', name: 'Slide + Fade Cross', kf: 'slideFadeCross', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', slideX: 80 },
        { id: 'morph-09', name: 'Vertical Drop', kf: 'verticalDrop', duration: 520, easing: 'cubic-bezier(0.20, 0.90, 0.20, 1)', dropY: 64 },
        { id: 'morph-10', name: 'Diagonal Slash', kf: 'diagonalSlash', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', slashX: 72, slashY: -72 },

        { id: 'morph-11', name: 'Squash & Stretch', kf: 'squashStretch', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-12', name: 'Blur Burst', kf: 'blurBurst', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', blurPx: 10 },
        { id: 'morph-13', name: 'Shutter Wipe', kf: 'shutterWipe', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-14', name: 'Portal Zoom Through', kf: 'portalZoom', duration: 620, easing: 'cubic-bezier(0.16, 1, 0.3, 1)', portal: 1.22 },
        { id: 'morph-15', name: 'Card Stack Lift', kf: 'stackLift', duration: 560, easing: 'cubic-bezier(0.18, 0.80, 0.20, 1)', lift: 18 },
        { id: 'morph-16', name: 'Parallax Drift', kf: 'parallaxDrift', duration: 620, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', driftX: 18, driftY: -12 },
        { id: 'morph-17', name: 'Skew Shear', kf: 'skewShear', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', skewDeg: 10 },
        { id: 'morph-18', name: 'Glitch Jitter', kf: 'glitchJitter', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-19', name: 'Ripple Expand', kf: 'rippleExpand', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-20', name: 'Cinematic Ease', kf: 'cinematicEase', duration: 720, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' }
      ];

      function getOpenMorphProfileForCard(card) {
        // Force ALL cards to use the same open morph as B6 (morph-16: Parallax Drift).
        const forced = OPEN_MORPH_PROFILES.find(p => p.id === 'morph-01');
        return forced || OPEN_MORPH_PROFILES[0];
      }

      function buildBoostedShadow(baseShadow, boost) {
        const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim() || '#e31b23';
        const glowA = 10 + Math.round(22 * boost);
        const glowB = 26 + Math.round(54 * boost);
        const alphaA = (0.18 + 0.45 * boost).toFixed(2);
        const alphaB = (0.10 + 0.28 * boost).toFixed(2);
        const extra = `0 0 ${glowA}px rgba(227,27,35,${alphaA}), 0 0 ${glowB}px rgba(227,27,35,${alphaB})`;
        if (!baseShadow || baseShadow === 'none') return extra;
        return `${baseShadow}, ${extra}`;
      }

      function animateOpenTile(tile, startRect, endRect, cardRadius, targetRadius, previewShadow, previewBorderColor, profile) {
        const fill = tile.querySelector('.preview-morph-fill');

        const startTileShadow = getComputedStyle(tile).boxShadow;
        const startTileBorderColor = getComputedStyle(tile).borderColor;

        const startX = startRect.left;
        const startY = startRect.top;
        const endX = endRect.left;
        const endY = endRect.top;

        const startW = startRect.width;
        const startH = startRect.height;
        const endW = endRect.width;
        const endH = endRect.height;

        const dX = endX - startX;
        const dY = endY - startY;

        const baseStart = {
          transform: `translate(${startX}px, ${startY}px)`,
          width: `${startW}px`,
          height: `${startH}px`,
          borderRadius: cardRadius,
          boxShadow: startTileShadow,
          borderColor: startTileBorderColor,
          opacity: 1,
          filter: 'none'
        };

        const baseEnd = {
          transform: `translate(${endX}px, ${endY}px)`,
          width: `${endW}px`,
          height: `${endH}px`,
          borderRadius: targetRadius,
          boxShadow: previewShadow,
          borderColor: previewBorderColor,
          opacity: 1,
          filter: 'none'
        };

        // Ensure a clean baseline (no residual transforms / filters).
        tile.style.transition = 'none';
        tile.style.transformOrigin = 'top left';
        tile.style.filter = 'none';
        tile.style.opacity = '1';
        tile.style.clipPath = '';
        tile.style.borderRadius = cardRadius;
        tile.style.boxShadow = startTileShadow;
        tile.style.borderColor = startTileBorderColor;

        if (fill) {
          fill.style.filter = 'none';
          fill.style.opacity = '1';
          fill.style.clipPath = '';
          fill.style.transform = 'none';
          fill.style.backgroundPosition = 'center';
        }

        const kf = (profile && profile.kf) ? profile.kf : 'straight';
        const dur = (profile && profile.duration) ? profile.duration : MORPH_DURATION;
        const ease = (profile && profile.easing) ? profile.easing : PREVIEW_EASING;

        const kfs = [];
        let options = { duration: dur, easing: ease, fill: 'forwards' };

        // Some concepts benefit from per-segment easing (keyframe easings).
        const midShadowStrong = buildBoostedShadow(previewShadow, 0.70);
        const midShadowSoft = buildBoostedShadow(previewShadow, 0.35);

        const add = (obj) => kfs.push(obj);

        if (kf === 'straight') {
          add({ offset: 0, ...baseStart });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'arcSweep') {
          const ax = (profile && profile.arcX != null) ? profile.arcX : 40;
          const ay = (profile && profile.arcY != null) ? profile.arcY : -28;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.55,
            transform: `translate(${startX + dX * 0.55 + ax}px, ${startY + dY * 0.55 + ay}px) rotate(0deg)`,
            width: `${startW + (endW - startW) * 0.55}px`,
            height: `${startH + (endH - startH) * 0.55}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.70)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'overshootSnap') {
          const os = (profile && profile.overshoot != null) ? profile.overshoot : 16;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.78,
            transform: `translate(${endX + os}px, ${endY - os * 0.45}px)`,
            width: `${endW * 1.02}px`,
            height: `${endH * 1.02}px`,
            borderRadius: `calc(${targetRadius} * 0.92)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
          });
          add({
            offset: 1,
            ...baseEnd,
            easing: 'cubic-bezier(0.20, 0.80, 0.20, 1)'
          });
        }

        else if (kf === 'springElastic') {
          const b = (profile && profile.bounce != null) ? profile.bounce : 3;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.58,
            transform: `translate(${endX + 18}px, ${endY - 10}px)`,
            width: `${endW * 1.04}px`,
            height: `${endH * 1.04}px`,
            borderRadius: `calc(${targetRadius} * 0.88)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
          });
          add({
            offset: 0.74,
            transform: `translate(${endX - 10}px, ${endY + 6}px)`,
            width: `${endW * 0.99}px`,
            height: `${endH * 0.99}px`,
            borderRadius: `calc(${targetRadius} * 1.02)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
          });
          if (b >= 3) {
            add({
              offset: 0.86,
              transform: `translate(${endX + 4}px, ${endY - 3}px)`,
              width: `${endW * 1.01}px`,
              height: `${endH * 1.01}px`,
              borderRadius: targetRadius,
              boxShadow: previewShadow,
              borderColor: previewBorderColor,
              easing: 'cubic-bezier(0.20, 0.80, 0.20, 1)'
            });
          }
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'hingeFlip') {
          const tilt = (profile && profile.tilt != null) ? profile.tilt : 10;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.45,
            transform: `translate(${startX + dX * 0.45}px, ${startY + dY * 0.45}px) perspective(900px) rotateX(${tilt}deg) rotateZ(-4deg)`,
            width: `${startW + (endW - startW) * 0.45}px`,
            height: `${startH + (endH - startH) * 0.45}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.55)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) perspective(900px) rotateX(-4deg) rotateZ(2deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'yawRotate') {
          const yaw = (profile && profile.yaw != null) ? profile.yaw : 14;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52}px, ${startY + dY * 0.52}px) perspective(900px) rotateY(${yaw}deg)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.60)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) perspective(900px) rotateY(-6deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'popInPlace') {
          // Lingers near start, then "pops" and travels late.
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.40,
            transform: `translate(${startX + dX * 0.12}px, ${startY + dY * 0.12}px) scale(1.08)`,
            width: `${startW + (endW - startW) * 0.18}px`,
            height: `${startH + (endH - startH) * 0.18}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.30)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            opacity: 1
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) scale(1.02)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'slideFadeCross') {
          const slideX = (profile && profile.slideX != null) ? profile.slideX : 80;

          add({ offset: 0, ...baseStart, opacity: 1 });
          add({
            offset: 0.45,
            transform: `translate(${startX + dX * 0.45 + slideX}px, ${startY + dY * 0.45}px)`,
            width: `${startW + (endW - startW) * 0.45}px`,
            height: `${startH + (endH - startH) * 0.45}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.50)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            opacity: 0.45
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor,
            opacity: 1
          });
          add({ offset: 1, ...baseEnd, opacity: 1 });
        }

        else if (kf === 'verticalDrop') {
          const drop = (profile && profile.dropY != null) ? profile.dropY : 64;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.60,
            transform: `translate(${startX + dX * 0.60}px, ${startY + dY * 0.60 + drop}px)`,
            width: `${startW + (endW - startW) * 0.60}px`,
            height: `${startH + (endH - startH) * 0.60}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.68)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.86,
            transform: `translate(${endX}px, ${endY}px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'diagonalSlash') {
          const sx = (profile && profile.slashX != null) ? profile.slashX : 72;
          const sy = (profile && profile.slashY != null) ? profile.slashY : -72;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52 + sx}px, ${startY + dY * 0.52 + sy}px) rotate(-6deg)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.62)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.80,
            transform: `translate(${endX}px, ${endY}px) rotate(2deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'squashStretch') {
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.28,
            transform: `translate(${startX + dX * 0.28}px, ${startY + dY * 0.28}px) scaleX(0.92) scaleY(1.08)`,
            width: `${startW + (endW - startW) * 0.28}px`,
            height: `${startH + (endH - startH) * 0.28}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.42)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.58,
            transform: `translate(${startX + dX * 0.58}px, ${startY + dY * 0.58}px) scaleX(1.08) scaleY(0.96)`,
            width: `${startW + (endW - startW) * 0.58}px`,
            height: `${startH + (endH - startH) * 0.58}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.70)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'blurBurst') {
          const blurPx = (profile && profile.blurPx != null) ? profile.blurPx : 10;

          add({ offset: 0, ...baseStart, filter: 'blur(0px)' });
          add({
            offset: 0.48,
            transform: `translate(${startX + dX * 0.48}px, ${startY + dY * 0.48}px)`,
            width: `${startW + (endW - startW) * 0.48}px`,
            height: `${startH + (endH - startH) * 0.48}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.60)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            filter: `blur(${blurPx}px)`
          });
          add({ offset: 0.72, filter: 'blur(0px)' });
          add({ offset: 1, ...baseEnd, filter: 'blur(0px)' });
        }

        else if (kf === 'shutterWipe') {
          // Tile moves normally; the fill reveals like a shutter wipe.
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.55,
            transform: `translate(${startX + dX * 0.55}px, ${startY + dY * 0.55}px)`,
            width: `${startW + (endW - startW) * 0.55}px`,
            height: `${startH + (endH - startH) * 0.55}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.70)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });

          if (fill) {
            try {
              fill.animate([
                { offset: 0, clipPath: 'inset(0 0 0 0)' },
                { offset: 0.18, clipPath: 'inset(0 0 0 0)' },
                { offset: 0.55, clipPath: 'inset(0 0 0 100%)' },
                { offset: 0.74, clipPath: 'inset(0 0 0 0)' },
                { offset: 1, clipPath: 'inset(0 0 0 0)' }
              ], { duration: dur, easing: 'linear', fill: 'forwards' });
            } catch (e) { /* no-op */ }
          }
        }

        else if (kf === 'portalZoom') {
          const portal = (profile && profile.portal != null) ? profile.portal : 1.22;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.72,
            transform: `translate(${endX}px, ${endY}px) scale(${portal})`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.88,
            transform: `translate(${endX}px, ${endY}px) scale(0.98)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'stackLift') {
          const lift = (profile && profile.lift != null) ? profile.lift : 18;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.45,
            transform: `translate(${startX + dX * 0.45}px, ${startY + dY * 0.45 - lift}px) perspective(900px) translateZ(24px)`,
            width: `${startW + (endW - startW) * 0.45}px`,
            height: `${startH + (endH - startH) * 0.45}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.55)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) perspective(900px) translateZ(0px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'parallaxDrift') {
          const driftX = (profile && profile.driftX != null) ? profile.driftX : 18;
          const driftY = (profile && profile.driftY != null) ? profile.driftY : -12;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.62,
            transform: `translate(${startX + dX * 0.62}px, ${startY + dY * 0.62}px)`,
            width: `${startW + (endW - startW) * 0.62}px`,
            height: `${startH + (endH - startH) * 0.62}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.74)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });

          if (fill) {
            try {
              fill.animate([
                { offset: 0, transform: 'translate(0px, 0px) scale(1.00)', backgroundPosition: 'center' },
                { offset: 0.55, transform: `translate(${driftX}px, ${driftY}px) scale(1.06)`, backgroundPosition: '60% 40%' },
                { offset: 1, transform: 'translate(0px, 0px) scale(1.00)', backgroundPosition: 'center' }
              ], { duration: dur, easing: ease, fill: 'forwards' });
            } catch (e) { /* no-op */ }
          }
        }

        else if (kf === 'skewShear') {
          const skewDeg = (profile && profile.skewDeg != null) ? profile.skewDeg : 10;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52}px, ${startY + dY * 0.52}px) skewX(${skewDeg}deg)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.64)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.80,
            transform: `translate(${endX}px, ${endY}px) skewX(-4deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'glitchJitter') {
          // Brief jitter micro-movements mid-flight.
          add({ offset: 0, ...baseStart });
          add({ offset: 0.40, transform: `translate(${startX + dX * 0.40}px, ${startY + dY * 0.40}px)`, width: `${startW + (endW - startW) * 0.40}px`, height: `${startH + (endH - startH) * 0.40}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.54)`, boxShadow: midShadowSoft, borderColor: previewBorderColor });
          add({ offset: 0.52, transform: `translate(${startX + dX * 0.52 + 6}px, ${startY + dY * 0.52 - 4}px)`, width: `${startW + (endW - startW) * 0.52}px`, height: `${startH + (endH - startH) * 0.52}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.64)`, boxShadow: midShadowSoft, borderColor: previewBorderColor });
          add({ offset: 0.56, transform: `translate(${startX + dX * 0.56 - 5}px, ${startY + dY * 0.56 + 3}px)`, width: `${startW + (endW - startW) * 0.56}px`, height: `${startH + (endH - startH) * 0.56}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.68)`, boxShadow: midShadowSoft, borderColor: previewBorderColor });
          add({ offset: 0.60, transform: `translate(${startX + dX * 0.60 + 4}px, ${startY + dY * 0.60 + 1}px)`, width: `${startW + (endW - startW) * 0.60}px`, height: `${startH + (endH - startH) * 0.60}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.72)`, boxShadow: midShadowStrong, borderColor: previewBorderColor });
          add({ offset: 0.68, transform: `translate(${startX + dX * 0.68}px, ${startY + dY * 0.68}px)`, width: `${startW + (endW - startW) * 0.68}px`, height: `${startH + (endH - startH) * 0.68}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.78)`, boxShadow: previewShadow, borderColor: previewBorderColor });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'rippleExpand') {
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52}px, ${startY + dY * 0.52}px) scale(1.08)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.66)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor,
            opacity: 0.85
          });
          add({
            offset: 0.72,
            transform: `translate(${startX + dX * 0.72}px, ${startY + dY * 0.72}px) scale(0.98)`,
            width: `${startW + (endW - startW) * 0.72}px`,
            height: `${startH + (endH - startH) * 0.72}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.82)`,
            boxShadow: previewShadow,
            borderColor: previewBorderColor,
            opacity: 1
          });
          add({ offset: 1, ...baseEnd, opacity: 1 });
        }

        else if (kf === 'cinematicEase') {
          // Slow start, fast mid, slow end + subtle radius timing offset.
          options = { duration: dur, easing: 'linear', fill: 'forwards' };

          add({ offset: 0, ...baseStart, easing: 'cubic-bezier(0.40, 0.00, 0.60, 1)' });
          add({
            offset: 0.22,
            transform: `translate(${startX + dX * 0.18}px, ${startY + dY * 0.18}px)`,
            width: `${startW + (endW - startW) * 0.18}px`,
            height: `${startH + (endH - startH) * 0.18}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.22)`,
            boxShadow: 'none',
            borderColor: 'rgba(255,255,255,0.10)',
            easing: 'cubic-bezier(0.40, 0.00, 0.60, 1)'
          });
          add({
            offset: 0.62,
            transform: `translate(${startX + dX * 0.74}px, ${startY + dY * 0.74}px)`,
            width: `${startW + (endW - startW) * 0.74}px`,
            height: `${startH + (endH - startH) * 0.74}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.55)`, /* radius lags */
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
          });
          add({
            offset: 0.86,
            transform: `translate(${endX}px, ${endY}px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.86)`,
            boxShadow: previewShadow,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.40, 0.00, 0.60, 1)'
          });
          add({ offset: 1, ...baseEnd });
        }

        // Safety fallback
        if (!kfs.length) {
          kfs.push({ offset: 0, ...baseStart });
          kfs.push({ offset: 1, ...baseEnd });
        }

        const anim = tile.animate(kfs, options);

        // Hard constraint: end clean (no rotation, skew, blur, opacity issues).
        anim.onfinish = () => {
          tile.style.transform = baseEnd.transform;
          tile.style.width = baseEnd.width;
          tile.style.height = baseEnd.height;
          tile.style.borderRadius = baseEnd.borderRadius;
          tile.style.boxShadow = baseEnd.boxShadow;
          tile.style.borderColor = baseEnd.borderColor;
          tile.style.opacity = '1';
          tile.style.filter = 'none';
          tile.style.clipPath = '';

          if (fill) {
            fill.style.filter = 'none';
            fill.style.clipPath = '';
            fill.style.transform = 'none';
            fill.style.backgroundPosition = 'center';
          }
        };

        return anim;
      }

      function measurePreviewRect() {
        const previewCard = previewOverlay.querySelector('.preview-card');
        if (!previewCard) return null;

        const wasVisible = previewOverlay.classList.contains('is-visible');
        const wasActive = previewCard.classList.contains('is-active');
        const previousOverlayTransition = previewOverlay.style.transition;
        const previousCardTransition = previewCard.style.transition;
        const previousOverlayOpacity = previewOverlay.style.opacity;
        const previousOverlayVisibility = previewOverlay.style.visibility;
        const previousOverlayPointerEvents = previewOverlay.style.pointerEvents;
        const previousTransform = previewCard.style.transform;
        const previousOpacity = previewCard.style.opacity;

        previewOverlay.style.transition = 'none';
        previewCard.style.transition = 'none';

        previewOverlay.classList.add('is-visible');
        previewOverlay.setAttribute('aria-hidden', 'false');
        previewOverlay.style.opacity = '0';
        previewOverlay.style.visibility = 'hidden';
        previewOverlay.style.pointerEvents = 'none';

        previewCard.classList.add('is-active');
        previewCard.style.transform = '';
        previewCard.style.opacity = '';

        const rect = previewCard.getBoundingClientRect();

        if (!wasVisible) {
        }

        if (!wasActive) {
          previewCard.classList.remove('is-active');
        }

        previewOverlay.style.transition = previousOverlayTransition;
        previewCard.style.transition = previousCardTransition;
        previewOverlay.style.opacity = previousOverlayOpacity;
        previewOverlay.style.visibility = previousOverlayVisibility;
        previewOverlay.style.pointerEvents = previousOverlayPointerEvents;
        previewCard.style.transform = previousTransform;
        previewCard.style.opacity = previousOpacity;

        return rect;
      }

      function createGlowTileFromCard(card, startRect) {
        const tile = document.createElement('div');
        tile.className = 'preview-morph-tile';

        const fill = document.createElement('div');
        fill.className = 'preview-morph-fill';

        tile.classList.remove('is-fade-out');
        fill.classList.remove('is-fade-out');
        tile.style.opacity = '';
        fill.style.opacity = '1';

        const posterImg = card.querySelector('img');
        if (posterImg && posterImg.src) {
          fill.style.backgroundImage = `url(${posterImg.src})`;
        }

        tile.appendChild(fill);
        tile.style.width = `${startRect.width}px`;
        tile.style.height = `${startRect.height}px`;
        tile.style.transformOrigin = 'top left';
        tile.style.transform = `translate(${startRect.left}px, ${startRect.top}px) scale(1, 1)`;
        document.body.appendChild(tile);

        return { tile, fill };
      }

      function moveTile(tile, startRect, targetRect, targetRadius) {
        tile.style.borderRadius = targetRadius;
        tile.style.width = `${targetRect.width}px`;
        tile.style.height = `${targetRect.height}px`;
        tile.style.transform = `translate(${targetRect.left}px, ${targetRect.top}px)`;
      }

      function openPreviewFromCard(card, triggerElement = card) {
        // ZAQ TASK 1.8: Pause hero video when preview begins opening.
        try {
          if (typeof ytPlayer !== 'undefined' && ytPlayer && typeof ytPlayer.pauseVideo === 'function') {
            try {
              if (typeof ytPlayer.getCurrentTime === 'function') {
                const t = ytPlayer.getCurrentTime();
                if (typeof t === 'number' && isFinite(t)) {
                  heroPausedTime = t;
                }
              }
            } catch (_) {}
            ytPlayer.pauseVideo();
          }
        } catch (_) {}
        const title = 'Preview Placeholder Title';
        const runtime = '1h 52m';
        const tags = 'Thriller â€¢ Sciâ€‘Fi â€¢ Action';
        const description = 'This is a static placeholder description used for layout validation only. It is intentionally long so the text wraps across multiple lines and reveals spacing, rhythm, and hierarchy inside the Preview Modal. Replace this copy with real content in a later task once the layout has been visually approved.';
previewTitleEl.textContent = title;
        previewRuntimeEl.textContent = runtime;
        previewTagsEl.textContent = tags;
        previewDescriptionEl.textContent = description;

        lastOpenedCard = triggerElement;
        lockScroll();
        previewOverlay.setAttribute('aria-hidden', 'false');
        const profile = getOpenMorphProfileForCard(card);
        currentMorphDuration = profile.duration;
        currentMorphEasing = profile.easing;
        // Sync overlay/card CSS variable timings to this open.
        previewOverlay.style.setProperty('--preview-morph-duration', `${profile.duration}ms`);
        previewOverlay.style.setProperty('--preview-morph-ease', profile.easing);
        const previewCard = previewOverlay.querySelector('.preview-card');
        if (previewCard) {
          previewCard.style.setProperty('--preview-morph-duration', `${profile.duration}ms`);
          previewCard.style.setProperty('--preview-morph-ease', profile.easing);
        }
        runOpenMorph(card, profile);
      }

      function runOpenMorph(card, profile) {
        return new Promise((resolve) => {
          const startRect = card.getBoundingClientRect();
          const previewCard = previewOverlay.querySelector('.preview-card');
          if (previewCard) {
            previewCard.style.opacity = '0';
            previewCard.style.transition = '';
            previewCard.classList.remove('is-hidden');
          }
          const endRect = measurePreviewRect();

          if (!previewCard || !endRect) {
            previewOverlay.classList.add('is-visible');
            previewCard.classList.add('is-active');
            resolve();
            return;
          }

          previewOverlay.style.opacity = '';
          previewOverlay.style.pointerEvents = '';
          previewOverlay.classList.add('is-visible');
          previewOverlay.setAttribute('aria-hidden', 'false');
          previewCard.classList.add('is-active');
          previewCard.style.opacity = '0';
          previewCard.style.transition = '';
          previewCard.style.transform = '';

          const previewShadow = getComputedStyle(previewCard).boxShadow;
          const previewBorderColor = getComputedStyle(previewCard).borderColor;

          const { tile, fill } = createGlowTileFromCard(card, startRect);

          const originalPreviewParent = previewCard.parentElement;
          const originalPreviewNextSibling = previewCard.nextSibling;

          tile.appendChild(previewCard);

          previewCard.style.position = 'absolute';
          previewCard.style.inset = '0';
          previewCard.style.width = '100%';
          previewCard.style.height = '100%';
          previewCard.style.margin = '0';
          previewCard.style.border = '0';
          previewCard.style.boxShadow = 'none';
          previewCard.style.borderRadius = 'inherit';
          previewCard.style.overflow = 'hidden';

          activeMorphTile = tile;
          const cardRadius = getComputedStyle(card).borderRadius;
          tile.style.borderRadius = cardRadius;
          const targetRadius = getComputedStyle(previewCard).borderRadius;

          fill.style.transition = '';
          fill.style.opacity = '1';

          let hasCrossfaded = false;

          const finishCrossfade = () => {
            if (!hasCrossfaded) return;

            if (originalPreviewParent) {
              if (originalPreviewNextSibling && originalPreviewNextSibling.parentNode === originalPreviewParent) {
                originalPreviewParent.insertBefore(previewCard, originalPreviewNextSibling);
              } else {
                originalPreviewParent.appendChild(previewCard);
              }
            }

            previewCard.style.position = '';
            previewCard.style.inset = '';
            previewCard.style.width = '';
            previewCard.style.height = '';
            previewCard.style.margin = '';
            previewCard.style.border = '';
            previewCard.style.boxShadow = '';
            previewCard.style.borderRadius = '';
            previewCard.style.overflow = '';

            tile.remove();
            if (activeMorphTile === tile) {
              activeMorphTile = null;
            }
            previewCard.style.transition = '';
            previewCard.style.opacity = '';
            resolve();
          };

          const handleCardFadeInEnd = (event) => {
            if (event.propertyName !== 'opacity') return;
            previewCard.removeEventListener('transitionend', handleCardFadeInEnd);
            finishCrossfade();
          };

          const startCrossfade = () => {
            if (hasCrossfaded) return;
            hasCrossfaded = true;
            previewCard.addEventListener('transitionend', handleCardFadeInEnd);
            previewCard.style.transition = `opacity ${FILL_FADE_DURATION}ms ${currentMorphEasing}`;
            fill.style.transition = `opacity ${FILL_FADE_DURATION}ms ${currentMorphEasing}`;
            previewCard.style.opacity = '1';
            fill.style.opacity = '0';

            setTimeout(() => {
              previewCard.removeEventListener('transitionend', handleCardFadeInEnd);
              finishCrossfade();
            }, FILL_FADE_DURATION + 120);
          };

          const resolvedProfile = profile || getOpenMorphProfileForCard(card);

          // Run per-card unique open morph (start/end geometry unchanged).
          const tileAnim = animateOpenTile(
            tile,
            startRect,
            endRect,
            cardRadius,
            targetRadius,
            previewShadow,
            previewBorderColor,
            resolvedProfile
          );

          tileAnim.onfinish = () => {
            startCrossfade();
          };

          setTimeout(() => {
            startCrossfade();
          }, resolvedProfile.duration + 140);
        });
      }

      function closePreview() {
        if (!previewOverlay || !previewOverlay.classList.contains('is-visible')) return;

        const previewCard = previewOverlay.querySelector('.preview-card');
        if (!previewCard) return;

        const previewCardRect = previewCard.getBoundingClientRect();
        if (!lastOpenedCard) {
          previewOverlay.classList.remove('is-visible');
          previewOverlay.setAttribute('aria-hidden', 'true');
          previewCard.classList.remove('is-active');
          previewCard.style.opacity = '';
          previewCard.style.pointerEvents = '';
          if (activeMorphTile && activeMorphTile.parentNode) {
            activeMorphTile.parentNode.removeChild(activeMorphTile);
          }
          activeMorphTile = null;
          unlockScroll();
          lastOpenedCard = null;
          resumeHeroAfterPreviewClose();
          return;
        }
        const cardRect = lastOpenedCard.getBoundingClientRect();

        let tile = activeMorphTile;
        let fill = null;

        if (!tile) {
          const created = createGlowTileFromCard(lastOpenedCard, previewCardRect);
          tile = created.tile;
          fill = created.fill;
          activeMorphTile = tile;
        } else {
          tile.style.borderRadius = getComputedStyle(previewCard).borderRadius;
          tile.style.width = `${previewCardRect.width}px`;
          tile.style.height = `${previewCardRect.height}px`;
          tile.style.transform = `translate(${previewCardRect.left}px, ${previewCardRect.top}px)`;
          tile.classList.remove('is-fade-out');
          tile.style.opacity = '';
          fill = tile.querySelector('.preview-morph-fill');
          if (fill) {
            fill.classList.remove('is-fade-out');
            fill.style.opacity = '1';
            const posterImg = lastOpenedCard.querySelector('img');
            if (posterImg && posterImg.src) {
              fill.style.backgroundImage = `url(${posterImg.src})`;
            }
          }
        }

        previewCard.style.opacity = '0';
        previewCard.style.pointerEvents = 'none';

        previewOverlay.classList.remove('is-visible');
        previewOverlay.setAttribute('aria-hidden', 'true');

        const targetRadius = getComputedStyle(lastOpenedCard).borderRadius;

        // Keep close timing compatible with the last open profile.
        tile.style.setProperty('--preview-morph-duration', `${currentMorphDuration}ms`);
        tile.style.setProperty('--preview-morph-ease', currentMorphEasing);

        requestAnimationFrame(() => {
          tile.offsetHeight;
          moveTile(tile, previewCardRect, cardRect, targetRadius);
        });

        setTimeout(() => {
          previewCard.classList.remove('is-active');
          previewCard.style.opacity = '';
          previewCard.style.pointerEvents = '';

          if (tile && tile.parentNode) {
            tile.parentNode.removeChild(tile);
          }
          if (activeMorphTile === tile) {
            activeMorphTile = null;
          }
          activeMorphTile = null;

          unlockScroll();

          if (lastOpenedCard && document.body.contains(lastOpenedCard)) {
            lastOpenedCard.focus();
          }
          lastOpenedCard = null;
          resumeHeroAfterPreviewClose();
        }, currentMorphDuration);
      }

      previewCloseButton.addEventListener('click', () => {
        closePreview();
      });

      previewOverlay.addEventListener('click', (event) => {
        const previewCard = previewOverlay.querySelector('.preview-card');
        if (!previewCard) return;
        if (previewCard.contains(event.target)) return;
        closePreview();
      });

      document.addEventListener('click', (event) => {
        const previewButton = event.target.closest('.poster-preview-button');
        if (!previewButton) return;

        const card = previewButton.closest('.poster');
        if (!card) return;

        event.preventDefault();
        event.stopPropagation();
        openPreviewFromCard(card, previewButton);
      }, true);

      document.addEventListener('keydown', (event) => {
        // Open preview from focused poster using Enter/Space.
        if ((event.key === 'Enter' || event.key === ' ') && !previewOverlay.classList.contains('is-visible')) {
          const active = document.activeElement;
          const card = active ? active.closest('.poster[data-morph-id]') : null;
          if (card) {
            event.preventDefault();
            openPreviewFromCard(card, card);
          }
        }
      });

document.addEventListener('keydown', (event) => {
        if ((event.key === 'Escape' || event.key === 'Esc') && previewOverlay.classList.contains('is-visible')) {
          event.preventDefault();
          closePreview();
        }
      });
    });
  </script>

  <!-- Preview Overlay (static skeleton) -->
  <div class="preview-overlay" aria-hidden="true">
    <div class="preview-card" role="dialog" aria-modal="true" aria-labelledby="preview-title">
      <button class="preview-close-btn" type="button" aria-label="Close preview">Ã—</button>
      <div class="preview-media">
        <!-- Later: video or wide poster goes here -->
        <div class="preview-media-placeholder"></div>
      </div>
      <div class="preview-info">
        <header class="preview-header">
          <h2 id="preview-title" class="preview-title">Preview Placeholder Title</h2>
          <div class="preview-meta">
            <span class="preview-runtime">1h 52m</span>
            <span class="preview-tags">Thriller â€¢ Sciâ€‘Fi â€¢ Action</span>
          </div>
        </header>
        <div class="preview-body">
          <p class="preview-description">
            
            This is a static placeholder description used for layout validation only. It is intentionally long so the text wraps across multiple lines and reveals spacing, rhythm, and hierarchy inside the Preview Modal. Replace this copy with real content in a later task once the layout has been visually approved.
          
          </p>
        </div>
        <div class="preview-actions">
          <button class="preview-play-button" type="button">
            Play
          </button>
          <button class="preview-details-button" type="button">
            Details
          </button>
        </div>
      </div>
    </div>
  </div>


</body>
</html>



