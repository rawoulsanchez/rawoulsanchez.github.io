<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SanchezPortfolio</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Google Fonts: Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />

<style>
/* ---------------- Base ---------------- */
body{background:#0d0d0d;font-family:'Inter',sans-serif;color:#f5f5f5}
.no-scrollbar::-webkit-scrollbar{display:none}.no-scrollbar{-ms-overflow-style:none;scrollbar-width:none}
.content-card{transition:transform .3s cubic-bezier(.25,.8,.25,1),box-shadow .3s ease;transform-origin:center;z-index:1}
.content-card:hover{will-change:transform;transform:scale(1.4);z-index:999;box-shadow:0 15px 30px -5px rgba(0,0,0,.9)}
.title-chip{display:inline-flex;align-items:center;justify-content:center;padding:.5rem .875rem;background:rgba(17,17,17,.85);border-radius:.75rem;box-shadow:0 6px 20px rgba(0,0,0,.45),inset 0 0 0 2px rgba(229,9,20,.65)}
.title-chip-text{font-weight:800;letter-spacing:.08em;color:#e50914;font-size:1.125rem}
@media (min-width:768px){.title-chip-text{font-size:1.5rem}}
@media (max-width:768px){.title-chip{padding:.4rem .75rem}.title-chip-text{font-size:1rem;letter-spacing:.09em}}
.content-shelf{padding-block:1.25rem;margin:0;content-visibility:auto;contain-intrinsic-size:600px}

/* ---------------- Hero video ---------------- */
.video-background-container{position:absolute;inset:0;overflow:hidden;z-index:0}
.video-background-container iframe{position:absolute;top:50%;left:50%;min-width:100vw;min-height:100vh;transform:translate(-50%,-50%);pointer-events:none}
@media (min-aspect-ratio:16/9){.video-background-container iframe{height:56.25vw;min-height:100vh}}
@media (max-aspect-ratio:16/9){.video-background-container iframe{width:177.78vh;min-width:100vw}}

/* ---------------- Preview ---------------- */
.hover-preview{position:fixed;z-index:9999;pointer-events:none;min-width:min(92vw,520px);max-width:min(92vw,520px);border-radius:.75rem;overflow:hidden;box-shadow:0 25px 70px rgba(0,0,0,.6),0 10px 25px rgba(0,0,0,.45);background:#111;opacity:0;transform:translate(0,0) scale(.98);transform-origin:top left;transition:transform .18s cubic-bezier(.2,.8,.2,1),opacity .16s ease}
.hp-backdrop{position:fixed;inset:0;z-index:9998;background:rgba(0,0,0,.35);display:none;touch-action:none}
body.no-scroll{overflow:hidden;overscroll-behavior:contain}
body.no-scroll main{overflow:hidden!important}
.hover-preview.show{opacity:1;transform:scale(1)}
.hover-preview .hp-banner{aspect-ratio:16/9;background-size:cover;background-position:center;position:relative}
.hover-preview .hp-banner::after{content:"";position:absolute;inset:0;background:linear-gradient(to top,rgba(0,0,0,.8),rgba(0,0,0,0) 55%)}
.hover-preview .hp-body{background:#1a1a1a;padding:14px 16px;display:flex;flex-direction:column;gap:10px;pointer-events:auto}

/* ---------------- Shelves (horizontal) ---------------- */
.shelf-row{overflow-x:auto;overflow-y:visible;overscroll-behavior-x:contain;overscroll-behavior-y:none;-webkit-overflow-scrolling:touch;scroll-snap-type:x proximity;touch-action:pan-x}
.card-track>.relative{scroll-snap-align:start}
@media (prefers-reduced-motion:reduce){.content-card,.hover-preview{transition:none!important}}
.content-card:focus-visible{outline:3px solid #e50914;outline-offset:2px}

/* ===================================================================
   ==============  MOBILE — CLEAN CONSOLIDATED RULES  =================
   =================================================================== */
@media (max-width:768px){
  /* Mobile anchor variables: adjust here to tune layout uniformly */
  :root{
    --m-hero-vid-w:192vw;          /* punch-in width (~50% total) */
    --m-hero-vid-h:108vw;          /* 16:9 of 192vw */
    --m-synopsis-firstline-offset:156px; /* baseline sits a touch higher */
    --m-gap-ctas-to-row:20px;      /* clearer gap above first shelf title */
  }

  /* 0) Punch the video in via vars */
  .video-background-container iframe{
    left:50%;top:0;transform:translateX(-50%);
    width:var(--m-hero-vid-w);
    height:var(--m-hero-vid-h);
    min-width:0;min-height:0;
  }

  /* 1) Hero layout: lower the text, small inline CTAs, leave a gap */
  .hero{
    min-height:64svh;         /* ensures room for overlayed content */
    background-color:#0f0f10;background-image:none;background-size:cover;background-position:center;
    padding-top:calc(env(safe-area-inset-top,0px) + 56px);
    padding-bottom:0;         /* baseline aligned via .hero-content */
    transition:transform 220ms cubic-bezier(.2,.8,.2,1);
  }

  /* Anchor the content to video bottom using variables */
  .hero .hero-content{
    position:absolute; left:0; right:0;
    top:calc(var(--m-hero-vid-h) - var(--m-synopsis-firstline-offset));
    /* keep original spacing styles from utility classes */
  }
  .hero.dimmed{transform:translateY(-8px) scale(.94)}
  .content-card:hover{transform:none!important;box-shadow:none!important;z-index:auto!important}

  /* Put buttons on one line, make them smaller */
  .hero .grid{gap:.5rem;grid-template-columns:repeat(2,minmax(0,1fr))}
  .hero .grid button{padding:.45rem .7rem;min-height:38px;border-radius:9999px}
  .hero .grid button svg{width:18px;height:18px}
  .hero .grid button .text-lg{font-size:.9rem;line-height:1.2rem}

  /* 2) Portrait posters — ~3 visible per viewport */
  .dock-card{
    width:28vw;               /* ≈3 across */
    max-width:6rem;           /* tighter cap for big phones */
    min-width:5rem;           /* guard for small phones */
    aspect-ratio:2/3;         /* portrait */
    height:auto;overflow:visible;
    transform-origin:center center;transition:transform 180ms cubic-bezier(.2,.8,.2,1),z-index 0s;
  }
  .card-track>*+*{margin-left:.5rem}
  .shelf-row{padding-block:.5rem}

  /* 3) Section snap for “vertical cards sliding” feel */
  main{scroll-snap-type:y mandatory;overscroll-behavior-y:contain;scroll-padding-top:calc(env(safe-area-inset-top,0px) + 56px);-webkit-overflow-scrolling:touch;scroll-behavior:smooth}
  main>section,.content-shelf{scroll-snap-align:start;scroll-snap-stop:normal}

  /* 4) Shelves are tighter; headings subtle */
  .content-shelf{min-height:56svh;padding-block:1.25svh;padding-inline:0;display:flex;flex-direction:column;justify-content:center;gap:.5rem}
  .content-shelf>h3{margin:0 0 .25rem 0!important;color:#e5e7eb;font-weight:700}
  .content-shelf>h3::after{content:"";display:block;height:1px;background:linear-gradient(to right,rgba(255,255,255,.18),rgba(255,255,255,.04));margin-top:.25rem}
  .content-shelf.shelf-active>h3{color:#fff}

  /* 5) Show only the top ~¼–⅓ of Row A below hero, with a clean gap */
  .content-shelf:first-of-type{margin-top:-12svh;padding-top:1.5rem}
  .content-shelf:first-of-type>h3{
    opacity:0;pointer-events:none;
    margin-top:var(--m-gap-ctas-to-row) !important;
  }
  .content-shelf.shelf-active:first-of-type>h3{opacity:1;pointer-events:auto}
}

/* moved: these mobile rules now live inside @media (max-width:768px) */
</style>
</head>
<body class="overflow-x-hidden overflow-y-hidden h-[100svh] md:overflow-y-visible md:h-auto">
  <!-- Fixed Navigation Bar -->
  <nav class="fixed top-0 left-0 right-0 bg-gradient-to-b from-black/90 to-transparent p-4 z-[100] flex items-center justify-between">   <div class="flex items-center space-x-8">     <a href="/" class="text-xl sm:text-2xl font-extrabold text-red-600 tracking-wide sm:tracking-wider whitespace-nowrap" aria-label="SanchezNinjah home">SanchezNinjah</a>     <ul class="hidden md:flex items-center space-x-6 text-sm font-medium text-gray-300">       <li><a href="/" class="text-white font-bold border-b-2 border-red-600 pb-1" aria-current="page">Home</a></li>       <li><a href="/shows" class="hover:text-white">TV Shows</a></li>       <li><a href="/movies" class="hover:text-white">Movies</a></li>       <li><a href="/list" class="hover:text-white">My List</a></li>     </ul>   </div>   <div class="flex items-center space-x-4">     <svg aria-hidden="true" focusable="false" class="w-6 h-6 text-gray-300 hover:text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>     <svg aria-hidden="true" focusable="false" class="w-6 h-6 text-gray-300 hover:text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>   </div> </nav>
<main class="h-[100svh] overflow-y-auto md:h-auto md:overflow-visible">
  <h1 class="sr-only">SanchezNinjah portfolio</h1>
    <!-- Hero Section -->
    <section class="hero relative min-h-[70svh] md:min-h-[100svh] flex items-end pb-4 md:pb-32 pt-0 md:pt-24 text-white">
      <div class="video-background-container">
        <iframe id="heroVideo" src="https://www.youtube-nocookie.com/embed/t1x7Q0IA3Os?autoplay=1&mute=1&loop=1&playlist=t1x7Q0IA3Os&controls=0&modestbranding=1&enablejsapi=1&start=8" title="Background trailer" playsinline referrerpolicy="strict-origin-when-cross-origin" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
      </div>
      <div class="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent z-0"></div>
      <div class="hero-content z-10 text-left max-w-[22rem] md:max-w-xl lg:max-w-3xl px-4 md:px-12 leading-relaxed">
        <div class="mb-3">
          <div class="title-chip mx-auto md:mx-0" role="heading" aria-level="1">
            <span class="title-chip-text">TITAN PROJECT</span>
          </div>
        </div>
        <p class="text-xs md:text-sm font-medium text-red-500 uppercase tracking-wide mb-2">New Release | Thriller, Sci-Fi | 2024</p>
        <p class="text-sm md:text-xl text-gray-200/90 leading-relaxed mb-6 font-light">As a rogue AI network threatens global collapse, a disgraced former agent is called back into the field for one last, impossible mission to save humanity.</p>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 md:gap-4 w-full max-w-sm">
          <button type="button" class="bg-white hover:bg-gray-200 text-black font-bold py-3 px-8 rounded-full transition-all hover:scale-[1.02] active:scale-[0.98] shadow-lg w-full flex items-center justify-center space-x-2">
            <svg aria-hidden="true" focusable="false" class="w-6 h-6" viewBox="0 0 20 20" fill="currentColor"><path d="M6 4l10 6-10 6V4z"/></svg>
            <span class="text-lg">Play Now</span>
          </button>
          <button type="button" class="bg-gray-700/70 hover:bg-gray-600/70 text-white font-bold py-3 px-8 rounded-full transition-all hover:scale-[1.02] active:scale-[0.98] shadow-lg w-full flex items-center justify-center space-x-2">
            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
            <span class="text-lg">Details</span>
          </button>
        </div>
      </div>

      <!-- Hero mute/unmute toggle -->
      <button
        id="heroMute"
        type="button"
        class="absolute top-4 right-4 z-20 bg-black/60 hover:bg-black/70 text-white w-10 h-10 rounded-full flex items-center justify-center backdrop-blur-md border border-white/20"
        aria-label="Toggle sound"
        aria-pressed="true"
      >
        <!-- speaker off icon -->
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <path d="M9 9v6h4l5 5V4l-5 5H9z"></path>
          <path d="M3 3l18 18"></path>
        </svg>
      </button>
    </section>

    <!-- Content Shelves Section -->
    <section class="relative z-10 space-y-2 px-0 md:px-8 pb-12">
      <div class="content-shelf px-6 md:px-4">
        <h3 class="text-xl md:text-2xl font-bold mb-2 ml-2">Popular on Stream (Scrolls Left)</h3>
        <div class="shelf-row relative overflow-x-auto overflow-y-visible no-scrollbar py-2 group/shelf"></div>
      </div>
      <div class="content-shelf px-6 md:px-4">
        <h3 class="text-xl md:text-2xl font-bold mb-2 ml-2">Trending Now (Scrolls Right)</h3>
        <div class="shelf-row relative overflow-x-auto overflow-y-visible no-scrollbar py-2 group/shelf"></div>
      </div>
      <div class="content-shelf px-6 md:px-4">
        <h3 class="text-xl md:text-2xl font-bold mb-2 ml-2">Design Inspiration (Scrolls Left)</h3>
        <div class="shelf-row relative overflow-x-auto overflow-y-visible no-scrollbar py-2 group/shelf"></div>
      </div>
    </section>
  </main>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // ---------- Constants ----------
    const ITEMS_PER_ROW = 10;
    const NUM_SETS = 3; // repeat for wrap buffer

    // Preview sizing and timing
    const PREVIEW_MIN_W = 520; // fixed
    const PREVIEW_MAX_W = 520; // fixed
    const PREVIEW_SCALE = 1.0; // ignored when min=max
    const PREVIEW_BODY_EXTRA = 110; // body below 16/9 banner
    const PREVIEW_DELAY = 800; // ms to open

    // Drag inertia
    const DRAG_DECAY = 0.92;
    const DRAG_MIN_VELOCITY = 0.8;

    // Edge resistance
    const MAX_PULL = 180;
    const PULL_FEEL = 0.6;
    const MAX_SCALE = 1.12;

    // ---------- Build or fetch hover preview ----------
function getHoverPreview() {
  if (!window.__hoverPreview) {
    const el = document.createElement('div');
    el.className = 'hover-preview';
    el.setAttribute('role', 'dialog');
    el.setAttribute('aria-modal', 'true');
    el.setAttribute('aria-label', 'Content preview');
    el.setAttribute('aria-hidden', 'true');
    el.innerHTML = `
      <div class="hp-banner"></div>
      <div class="hp-body">
        <div class="hp-title">Title</div>
        <div class="hp-meta">98% Match • 95m • HD</div>
        <div class="hp-btns">
          <button class="hp-btn" title="Play"><svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M6 4l10 6-10 6V4z"/></svg></button>
          <button class="hp-btn secondary" title="Add"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg></button>
        </div>
        <div class="hp-chips"></div>
      </div>`;

    const bd = document.createElement('div');
    bd.className = 'hp-backdrop';
    bd.setAttribute('aria-hidden','true');
    bd.setAttribute('role','presentation');
    bd.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      e.stopPropagation();
      hidePreviewImmediate();
    }, {capture:true});
    // Block scroll/drag while preview is open by consuming touchmove on the backdrop only
bd.addEventListener('touchmove', (e)=> e.preventDefault(), { passive: false });

    document.body.appendChild(bd);
    document.body.appendChild(el);

    window.__hoverPreview = el;
    window.__hoverBackdrop = bd;
  }
  return window.__hoverPreview;
}
    const hp = getHoverPreview();

    // ---------- Data ----------
    const shelves = document.querySelectorAll('.shelf-row');
    const rowsLetters = ['A','B','C'];
    const palette = ['bg-neutral-800','bg-blue-800','bg-green-800','bg-amber-800','bg-purple-800','bg-rose-700','bg-teal-800','bg-orange-600','bg-sky-700','bg-lime-700'];
    const makeRowData = (L)=> Array.from({length:ITEMS_PER_ROW}, (_,i)=>({ key:`${L}${i+1}`, color:palette[i%palette.length] }));

    // ---------- Helpers ----------
    const clamp = (x,min,max)=> Math.max(min, Math.min(max, x));
    const add = (cls)=> document.body.classList.add(cls);
    const remove = (cls)=> document.body.classList.remove(cls);

     /* removed: duplicate mobile center-pick for shelf-active.
       The IntersectionObserver at 0.7 handles this. */

    // Preview control state
let hoverTimer = null;
let currentPreviewCard = null;
let lastActiveShelf = null; 
let suppressHover = false; // blocks preview during drag/scroll
let suppressTapUntil = 0;  // blocks taps briefly after closing preview
let previewOpen = false;   // true while preview is shown
function blockTouchMove(e){ if (previewOpen) e.preventDefault(); }

function hidePreviewImmediate(){
  clearTimeout(hoverTimer);
  hp.classList.remove('show');
  hp.setAttribute('aria-hidden','true');
  hp.style.pointerEvents = 'none';
  hp.style.opacity = '0';
  hp.style.transform = 'translate(0,0) scale(0.98)';
  currentPreviewCard = null;

// hide backdrop and unlock scroll
if (window.__hoverBackdrop){
  const bd = window.__hoverBackdrop;
  bd.style.pointerEvents = 'none';
  bd.style.display = 'none';
}
remove('no-scroll');
document.removeEventListener('touchmove', blockTouchMove);

previewOpen = false; // preview is now closed

// brief tap suppression so swipe feels natural
suppressTapUntil = Date.now() + 200;
}

    // Close when mouse leaves the preview box
    hp.addEventListener('mouseleave', hidePreviewImmediate);
    hp.addEventListener('pointerleave', hidePreviewImmediate);

       // Extra hard closes
    document.addEventListener('pointerdown', (e)=>{                         // any click outside preview
      if (Date.now() < suppressTapUntil) { e.preventDefault(); e.stopPropagation(); return; }
      if (!hp.classList.contains('show')) return;
      const t = e.target;
      // do not close if click is inside the preview element
      if (hp.contains(t)) return;
      hidePreviewImmediate();
    }, true);   // any click outside preview
    window.addEventListener('blur', hidePreviewImmediate);                  // window loses focus
    document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') hidePreviewImmediate(); }, true);
    document.addEventListener('pointerout', (e)=>{                          // pointer leaves window
      if (!e.relatedTarget) hidePreviewImmediate();
    }, true);

    // Hard guard: while preview is open
    // - close if pointer is outside the preview
    // - also close if pointer is on a different card
    document.addEventListener('pointerover', (e) => {
      if (!hp.classList.contains('show')) return;
      const t = e.target;
      if (hp.contains(t)) return; // inside preview -> keep open
      const overOrigin = currentPreviewCard && currentPreviewCard.contains(t);
      const otherCard = t.closest('.content-card');
      if (!overOrigin || (otherCard && otherCard !== currentPreviewCard)) {
        hidePreviewImmediate();
      }
    }, true);

    // Hard guard #3: if the pointer is neither over the preview NOR the originating card, close
    document.addEventListener('mousemove', (e) => {
      if (!hp.classList.contains('show') || !currentPreviewCard) return;
      const pr = hp.getBoundingClientRect();
      const cr = currentPreviewCard.getBoundingClientRect();
      const inPreview = e.clientX>=pr.left && e.clientX<=pr.right && e.clientY>=pr.top && e.clientY<=pr.bottom;
      const inCard = e.clientX>=cr.left && e.clientX<=cr.right && e.clientY>=cr.top && e.clientY<=cr.bottom;
      if (!inPreview && !inCard) hidePreviewImmediate();
    });

    /* removed: redundant pointermove hard guard.
       pointerover + mousemove guards already handle outside/other-card cases. */

    // Global wheel closes preview instantly
    window.addEventListener('wheel', ()=>{ if (hp.classList.contains('show')) hidePreviewImmediate(); }, {passive:true});
    // Global scroll closes preview instantly (keyboard/page scroll, programmatic)
    document.addEventListener('scroll', ()=>{ if (hp.classList.contains('show')) hidePreviewImmediate(); }, true);

    // Show preview near a card
    function showPreview(cardEl, label){
      lastActiveShelf = cardEl.closest('.shelf-row');
      currentPreviewCard = cardEl;

      const rect = cardEl.getBoundingClientRect();
      const w = PREVIEW_MIN_W; // fixed
      const estH = w * 9/16 + PREVIEW_BODY_EXTRA;
      const left = clamp(rect.left, 16, innerWidth - w - 16);
      const top  = clamp(rect.top + rect.height/2 - estH/2, 16, innerHeight - estH - 16);

      hp.style.width = w+'px';
      hp.style.left  = left+'px';
      hp.style.top   = top+'px';

      const cssVar = `--${label}`;
      const bg = getComputedStyle(document.documentElement).getPropertyValue(cssVar);
      hp.querySelector('.hp-banner').style.backgroundImage = bg && bg.trim()? bg : 'linear-gradient(135deg,#1f2937,#0f172a)';
      hp.querySelector('.hp-title').textContent = label;
      hp.querySelector('.hp-chips').textContent = 'Action • Sci‑Fi • Trending';
      
      // show backdrop and lock scroll
add('no-scroll');
previewOpen = true;
if (window.__hoverBackdrop){
  const bd = window.__hoverBackdrop;
  bd.style.display = 'block';
  bd.style.pointerEvents = 'auto';
}
document.addEventListener('touchmove', blockTouchMove, { passive: false });

      // Morph in
      const startTx = rect.left - left;
      const startTy = rect.top  - top;
      const sx = rect.width / w;
      const sy = rect.height / estH;
      hp.setAttribute('aria-hidden','false');
      hp.classList.add('show');
      hp.style.pointerEvents = 'auto';
      hp.style.opacity = '0';
      hp.style.transform = `translate(${startTx}px, ${startTy}px) scale(${sx}, ${sy})`;
      requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ hp.style.opacity='1'; hp.style.transform='translate(0,0) scale(1,1)'; }); });
    }

    // ---------- Build shelves ----------
    shelves.forEach((shelf, idx) => {
      // Track element
      const track = document.createElement('div');
      track.className = 'card-track flex space-x-3 isolate drag-grab';
      track.style.position = 'relative';

      // Data for this row
      const rowData = makeRowData(rowsLetters[idx] || 'X');
      let html = '';
      for(let s=0;s<NUM_SETS;s++){
        for(let i=0;i<rowData.length;i++){
          const item = rowData[i];
          const cssVar = `--${item.key}`;
          const resistClass = i===0 ? 'resist-first' : '';
          html += `
            <div class="relative dock-card flex-shrink-0 w-56 md:w-64 h-32 md:h-36 group ${resistClass}">
              <div class="content-card absolute inset-0 ${item.color} rounded-md overflow-hidden cursor-pointer flex items-center justify-center">
                <div class="absolute inset-0" style="background-image:var(${cssVar}, none); background-size:cover; background-position:center;"></div>
                <div class="relative z-10 text-white text-3xl md:text-4xl font-extrabold tracking-wide select-none">${item.key}</div>
              </div>
            </div>`;
        }
      }
      // Pink COMING SOON plank
      html += `
        <div class="relative flex-shrink-0 w-[1200px] md:w-[1600px] h-32 md:h-36 rounded-xl bg-pink-600/90 flex items-center justify-center px-6">
          <div class="w-full text-black font-extrabold tracking-widest uppercase text-xl md:text-2xl whitespace-nowrap overflow-hidden">COMING SOON // COMING SOON // COMING SOON // COMING SOON // COMING SOON // COMING SOON // COMING SOON // COMING SOON</div>
        </div>`;

      track.innerHTML = html;
      shelf.appendChild(track);

      // Measure one-set width and set initial X to -setWidth (start at set 2)
      const setWidth = track.children[ITEMS_PER_ROW].offsetLeft;
      shelf.dataset.setWidth = String(setWidth);
      let currentX = -setWidth;
      shelf.dataset.currentX = String(currentX);
      track.style.transform = `translateX(${currentX}px)`;
      track.style.transition = 'transform 120ms linear';

      // Resistance helpers
      const firstTileEl = ()=> track.children[ITEMS_PER_ROW];
      const setFirstScale = (overflow)=>{ const s=1+Math.min(MAX_PULL,Math.max(0,overflow))/(MAX_PULL/(MAX_SCALE-1)); const el=firstTileEl(); el.classList.add('edge-active'); el.style.transform=`scaleX(${Math.min(s,MAX_SCALE)})`; };
      const clearFirstScale = ()=>{ const el=firstTileEl(); el.style.transform='none'; el.classList.remove('edge-active'); };
      const clampWithResistance = (x)=>{ const w=+shelf.dataset.setWidth; if(x>-w){ const raw=x+w; const pull=Math.min(MAX_PULL, raw*PULL_FEEL); setFirstScale(pull); return -w+pull; } clearFirstScale(); return x; };
      const wrapRightIfNeeded = (x)=>{ const w=+shelf.dataset.setWidth; if(x<-(NUM_SETS)*w) x += (NUM_SETS-1)*w; return x; };

      // Movement helper
      const moveBy = (delta) => { let x = +shelf.dataset.currentX + delta; x = clampWithResistance(x); x = wrapRightIfNeeded(x); shelf.dataset.currentX=String(x); track.style.transform=`translateX(${x}px)`; };
      shelf._moveBy = moveBy; // expose

const isCoarse = window.matchMedia('(pointer:coarse)').matches;
// Mouse wheel -> horizontal translate (desktop only)
if (!isCoarse) {
  const DIR = (idx === 1 ? -1 : 1); // middle shelf scrolls right
  shelf.addEventListener('wheel', (e)=>{
    e.preventDefault();
    suppressHover = true;
    clearTimeout(hoverTimer);
    const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;
    moveBy(-delta * DIR);
    hidePreviewImmediate();
    setTimeout(()=>{ suppressHover = false; }, 150);
  }, {passive:false});
}

     // Pointer dragging with inertia (desktop only)
if (!isCoarse) {
  let isDragging=false, lastX=0, v=0, inertiaId=null;
  const stopInertia=()=>{ if(inertiaId){ cancelAnimationFrame(inertiaId); inertiaId=null; } };
  shelf.addEventListener('pointerdown',(e)=>{
    if(e.button!==undefined && e.button!==0) return;
    stopInertia(); isDragging=true; lastX=e.clientX; v=0;
track.classList.remove('drag-grab'); track.classList.add('drag-grabbing');
suppressHover = true; clearTimeout(hoverTimer);
hidePreviewImmediate();
    try{ shelf.setPointerCapture(e.pointerId);}catch(_){ }
  });
  window.addEventListener('pointermove',(e)=>{
    if(!isDragging) return;
    const dx=e.clientX-lastX; lastX=e.clientX; v=dx;
    let x=+shelf.dataset.currentX+dx; x=clampWithResistance(x); x=wrapRightIfNeeded(x);
    shelf.dataset.currentX=String(x); track.style.transform=`translateX(${x}px)`;
  });
  const endDrag=(e)=>{
if(!isDragging) return; isDragging=false;
track.classList.remove('drag-grabbing'); track.classList.add('drag-grab');
setTimeout(()=>{ suppressHover = false; }, 150);
    try{ shelf.releasePointerCapture(e.pointerId);}catch(_){ }
    const step=()=>{
      if(Math.abs(v)<DRAG_MIN_VELOCITY){ inertiaId=null; return; }
      let x=+shelf.dataset.currentX+v; x=clampWithResistance(x); x=wrapRightIfNeeded(x);
      shelf.dataset.currentX=String(x); track.style.transform=`translateX(${x}px)`; v*=DRAG_DECAY;
      inertiaId=requestAnimationFrame(step);
    }; inertiaId=requestAnimationFrame(step);
  };
  window.addEventListener('pointerup', endDrag);
  window.addEventListener('pointercancel', endDrag);
} else {
  // Touch devices: rely on native horizontal scroll
  track.style.transition = '';
  track.style.transform = ''; // no transform; use native scroll position
  track.classList.remove('drag-grab','drag-grabbing');
}

      // Mobile dock magnification effect
if (isCoarse) {
  const cards = Array.from(track.querySelectorAll('.dock-card'));
  const updateDock = () => {
    // Only magnify when this shelf is active; otherwise keep baseline
    if (!shelf.classList.contains('shelf-active')) {
      cards.forEach(c => {
        c.style.transform = 'none';
        c.style.overflow = 'visible';
        const inner0 = c.querySelector('.content-card');
        if (inner0) inner0.style.transform = ''; // let CSS apply scale(0.92) on inactive shelves
        c.style.zIndex = '';
      });
      return;
    }

    const r = shelf.getBoundingClientRect();
    const center = r.left + r.width / 2;     // shelf's visual center

    // reset baseline so taps never leave a card small
    cards.forEach(c => {
      c.style.transform = 'none';
      c.style.overflow = 'visible';
      const inner0 = c.querySelector('.content-card');
      if (inner0) inner0.style.transform = 'translateY(4px) scale(1)';
    });

   cards.forEach(card => {
  const cr = card.getBoundingClientRect();
  const c  = cr.left + cr.width / 2;
  const dist  = Math.abs(c - center);
  const norm  = Math.min(1, dist / (r.width * 0.5)); // 0 center, 1 far edge

  // gentler magnification and lift
  const scale = Math.max(1, 1.0 + (1 - norm) * 0.24);
  const drop  = 3 + norm * 6;

  const inner = card.querySelector('.content-card');
  if (inner) {
    inner.style.transform = `translateY(${drop}px) scale(${scale})`;
    inner.style.willChange = 'transform';
  }

// ensure stacking without clipping
card.style.zIndex = String(1000 - Math.round(norm * 1000));
card.style.overflow = 'visible';
    });
  };

  // Run initially and on scroll/resize
  updateDock();
  shelf.addEventListener('scroll', updateDock, { passive: true });
  window.addEventListener('resize', updateDock);
  document.addEventListener('shelf-active-change', updateDock);
  shelf.addEventListener('touchstart', () => { if (previewOpen) hidePreviewImmediate(); }, { passive: true });
shelf.addEventListener('scroll',      () => { if (previewOpen) hidePreviewImmediate(); }, { passive: true });
}
      
// Auto-center nearest card after scroll settles (mobile)
if (isCoarse) {
  let alignTimer = null;

  const centerNearest = () => {
    // Only auto-center when this shelf is the active one
    if (!shelf.classList.contains('shelf-active')) return;

    const cards = Array.from(track.querySelectorAll('.dock-card'));
    if (!cards.length) return;

    const viewportCenter = window.innerWidth / 2;
    let best = { card: null, dist: Infinity };

    cards.forEach(card => {
      const cr = card.getBoundingClientRect();
      const c  = cr.left + cr.width / 2;
      const d  = Math.abs(c - viewportCenter);
      if (d < best.dist) best = { card, dist: d };
    });

    if (!best.card) return;
    const cardRect = best.card.getBoundingClientRect();
    const targetLeft =
      shelf.scrollLeft + (cardRect.left + cardRect.width / 2) - (shelf.clientWidth / 2);

    shelf.scrollTo({ left: targetLeft, behavior: 'smooth' });
  };

  const scheduleAlign = () => {
    if (alignTimer) clearTimeout(alignTimer);
    alignTimer = setTimeout(centerNearest, 240); // slower, more natural
  };

  // run once on load, and after user scrolls or resizes
  requestAnimationFrame(centerNearest);
  shelf.addEventListener('scroll', scheduleAlign, { passive: true });
  window.addEventListener('resize', scheduleAlign);
  shelf.addEventListener('touchend', scheduleAlign, { passive: true });
  // when vertical snap changes the active shelf, center immediately
  document.addEventListener('shelf-active-change', centerNearest);
}

      // Snap back on leave to remove stretched first tile
      shelf.addEventListener('mouseleave',()=>{ const w=+shelf.dataset.setWidth; if(+shelf.dataset.currentX>-w){ shelf.dataset.currentX=String(-w); track.style.transform=`translateX(${-w}px)`; } clearFirstScale(); });

// Hover on desktop. Tap-only on touch.
track.querySelectorAll('.content-card').forEach(card=>{
  const label = card.querySelector('.relative.z-10')?.textContent.trim() || '';
  card.setAttribute('tabindex','0');

  if (!isCoarse) {
card.addEventListener('mouseenter', ()=>{
  if (suppressHover) return;
  if (hp.classList.contains('show') && currentPreviewCard && currentPreviewCard!==card) hidePreviewImmediate();
  clearTimeout(hoverTimer);
  hoverTimer = setTimeout(()=>{
    if (suppressHover) return;
    showPreview(card, label);
  }, PREVIEW_DELAY);
});
    card.addEventListener('mouseleave', ()=>{ clearTimeout(hoverTimer); });
   card.addEventListener('focus', ()=>{
  if (suppressHover) return;
  clearTimeout(hoverTimer);
  showPreview(card, label);
});
   card.addEventListener('blur', ()=>{ hidePreviewImmediate(); });
} else {
  // Touch: open (or switch) preview on a real tap (not a swipe)
let tX = 0, tY = 0, tTime = 0;

card.addEventListener('touchstart', (e)=>{
  const t = e.changedTouches[0];
  tX = t.clientX; tY = t.clientY; tTime = Date.now();
}, {passive:true});

card.addEventListener('touchend', (e)=>{
  const t = e.changedTouches[0];
  const dx = Math.abs(t.clientX - tX);
  const dy = Math.abs(t.clientY - tY);
  const dt = Date.now() - tTime;

  // treat as tap only if quick and with little movement
  if (dx < 10 && dy < 10 && dt < 300) {
    // Only allow if this shelf is the active one and not in tap-suppression window
    const shelfEl = card.closest('.content-shelf');
    if (!shelfEl || !shelfEl.classList.contains('shelf-active')) return;
    if (Date.now() < suppressTapUntil) return;

    clearTimeout(hoverTimer);
    suppressHover = false;
    showPreview(card, label); // open/switch to this card
  }
}, {passive:true});
}
});

}); // <-- add this line

  // Public helper: set image for all duplicates of a key
  window.setThumb = (key, url) => {
    document.documentElement.style.setProperty(`--${key}`, `url(${url})`);
  };

  // Mobile: pause hero video when hero not active, play when active
  (function(){
    const isCoarse = window.matchMedia('(pointer:coarse)').matches;
    if (!isCoarse) return;

    const heroEl = document.querySelector('.hero');
    const iframe = document.getElementById('heroVideo');
    if (!heroEl || !iframe) return;

    // Ensure YouTube has an explicit origin for postMessage API reliability
    try{
      const u = new URL(iframe.src);
      if (!u.searchParams.has('origin')) {
        u.searchParams.set('origin', location.origin);
        iframe.src = u.toString();
      }
    }catch(_){}

    const ytCommand = (cmd) => {
      if (!iframe.contentWindow) return;
      iframe.contentWindow.postMessage(JSON.stringify({ event: 'command', func: cmd, args: [] }), '*');
    };

    // --- Mute/Unmute wiring ---
    const muteBtn = document.getElementById('heroMute');
    let isMuted = true; // starts muted per URL

    const post = (func, args=[]) => {
      if (!iframe.contentWindow) return;
      iframe.contentWindow.postMessage(JSON.stringify({ event: 'command', func, args }), '*');
    };

    const setIcon = (muted) => {
      // speaker-off vs speaker-on
      muteBtn.innerHTML = muted
        ? `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="M9 9v6h4l5 5V4l-5 5H9z"></path><path d="M3 3l18 18"></path></svg>`
        : `<svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="M9 9v6h4l5 5V4l-5 5H9z"></path><path d="M19 5a7 7 0 0 1 0 14"></path><path d="M16 8a4 4 0 0 1 0 8"></path></svg>`;
    };

    const applyMute = (muted) => {
      isMuted = muted;
      if (muteBtn) {
        muteBtn.setAttribute('aria-pressed', String(muted));
        setIcon(muted);
      }
      if (muted) {
        post('mute');
      } else {
        post('unMute');
        post('setVolume', [50]); // 0–100
      }
    };

    if (muteBtn) {
      setIcon(true); // initial icon
      muteBtn.addEventListener('click', () => applyMute(!isMuted));
    }
    // ---------------------------

    const io = new IntersectionObserver((entries)=>{
      const e = entries[0];
      if (!e) return;
      if (e.isIntersecting && e.intersectionRatio > 0.7) {
        heroEl.classList.remove('dimmed');
        ytCommand('playVideo');
      } else {
        heroEl.classList.add('dimmed');
        ytCommand('pauseVideo');
      }
    }, { threshold: [0, 0.5, 0.7, 0.9, 1] });

    io.observe(heroEl);

    // Also pause when page is hidden; resume on visible if hero is active
    document.addEventListener('visibilitychange', ()=>{
      if (document.hidden) {
        ytCommand('pauseVideo');
      } else {
        const r = heroEl.getBoundingClientRect();
        const visible = r.top < innerHeight && r.bottom > 0 && (Math.min(r.bottom, innerHeight) - Math.max(r.top, 0)) / r.height >= 0.7;
        if (visible) ytCommand('playVideo');
      }
    });
  })();

  // Mobile: mark the visible shelf as active for opacity highlight
  (function(){
    const isCoarse = window.matchMedia('(pointer:coarse)').matches;
    if (!isCoarse) return;

    const shelvesEls = Array.from(document.querySelectorAll('.content-shelf'));
    if (!shelvesEls.length) return;

    let active = null;
    const io = new IntersectionObserver((entries)=>{
      // pick the entry with the highest intersection ratio
      let best = null;
      for (const e of entries) {
        if (!best || e.intersectionRatio > best.intersectionRatio) best = e;
      }
      if (!best) return;
      // activate only when most of the shelf is in view to avoid flicker
      const el = best.target;
      if (best.isIntersecting && best.intersectionRatio >= 0.7) {
        if (active !== el) {
          shelvesEls.forEach(s => s.classList.toggle('shelf-active', s === el));
          active = el;
          document.dispatchEvent(new CustomEvent('shelf-active-change', { detail: { active: el } }));
        }
      }
    }, { threshold: [0, 0.5, 0.7, 0.9, 1] });

    shelvesEls.forEach(s => io.observe(s));
  })();

  // ---------- Smoke tests ----------
  console.group('[SanchezNinjah tests]');
  console.assert(document.querySelectorAll('.shelf-row').length===3, '3 shelves expected');
  console.assert(!!window.__hoverPreview, 'hover preview element exists');
  console.assert(typeof window.setThumb==='function','setThumb exposed');
  console.assert(getComputedStyle(document.querySelector('.hover-preview')).pointerEvents==='none','preview overlay pointer-events none');
  console.assert(document.querySelectorAll('.content-card').length>=30,'cards rendered');
  (function(){
    const hp = window.__hoverPreview;
    const okOpenClose = ()=>{
      hp.classList.add('show');
      hp.dispatchEvent(new Event('mouseleave'));
      return !hp.classList.contains('show');
    };
    console.assert(okOpenClose(), 'Preview hides on mouseleave event');
  })();
  console.groupEnd();
}); // <-- this is the ONLY closing brace for DOMContentLoaded
  </script>
</body>
</html>
