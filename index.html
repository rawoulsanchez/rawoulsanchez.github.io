


<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>All B6</title>
<style>
  /* Design tokens */
:root { --bg:#000; --fg:#eaeaf0; --muted:#9aa0a6; --accent:#7aa2ff; --nav-height:64px; --brand:#e31b23; --brand-glow-shadow:0 0 8px var(--brand), 0 0 24px color-mix(in srgb, var(--brand) 60%, transparent 40%); --preview-frame-radius:18px; --preview-frame-border:1px solid #262b33; --preview-frame-shadow:0 22px 60px rgba(0,0,0,0.80), 0 0 0 1px rgba(255,255,255,0.03), var(--brand-glow-shadow); --preview-morph-duration:340ms; --preview-morph-ease:cubic-bezier(0.22, 0.61, 0.36, 1); }
  :root{
  --font-ui: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
  --font-display: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
}
  * { box-sizing:border-box; }
  body { margin:0; font-family:var(--font-ui); background:var(--bg); color:var(--fg); line-height:1.5; overflow-x:hidden; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }

  /* Fixed black nav */
.nav-bar{
  position:fixed;
  top:0;
  left:0;
  right:0;
  z-index:12000;
  background:#000;
  height:calc(var(--nav-height) + env(safe-area-inset-top));
  box-shadow:none;
border-bottom:0;
}

/* Content sits below the notch area */
.nav-inner {
  max-width:960px;
  margin:0 auto;
  height:var(--nav-height);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  padding:env(safe-area-inset-top) 16px 0 16px; /* <-- moved from .nav-bar */
}
.brand {
    color:var(--brand);
    font-weight:800;
    font-size:24px;
    letter-spacing:.2px;
    text-decoration:none;
}
  .nav-links{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:18px;
    margin:0 24px;
    flex:1 1 auto;
    min-width:0;
    white-space:nowrap;
  }
  .nav-link{
    font-size:.82rem;
    font-weight:500;
    color:var(--muted);
    text-decoration:none;
    padding:4px 8px;
    border-radius:999px;
    transition:color .16s ease, background-color .16s ease, opacity .16s ease;
  }
  .nav-link:hover{
    color:var(--fg);
    background:#111;
  }
  .nav-link--active{
    color:#fff;
    background:rgba(255,255,255,0.10);
  }
  @media (max-width:640px){
    .nav-links{
      gap:12px;
      margin:0 12px;
      font-size:.78rem;
      white-space:normal;
      flex-wrap:wrap;
      justify-content:flex-start;
    }
    .nav-link{
      font-size:.78rem;
      padding:3px 6px;
    }
  }
  .nav-actions {
    display:flex;
    gap:12px;
    align-items:center;
  }
  .icon-btn {
    position:relative;
    display:inline-grid;
    place-items:center;
    width:36px;
    height:36px;
    border-radius:999px;
    background:#121212;
    border:1px solid #222;
    cursor:pointer;
    color:#eaeaf0;
  }
  .icon-btn:hover { background:#161616; }
  .icon-btn svg { fill:currentColor; }
.icon-btn .dot {
    position:absolute;
    top:4px;
    right:4px;
    width:9px;
    height:9px;
    background:var(--brand);
    border-radius:999px;
    box-shadow:0 0 0 2px #000;
}
  .title-chip{
  display:inline-flex; align-items:center; justify-content:center;
  padding:.5rem .875rem;
  background:rgba(17,17,17,.85);
  border-radius:.75rem;
  /* keep same visual weight and red border using token */
  box-shadow:
    0 6px 20px rgba(0,0,0,.45),
    inset 0 0 0 2px color-mix(in srgb, var(--brand) 65%, transparent);
  margin-bottom:.5rem;         /* preserves your current spacing */
}
.title-chip-text{
  font-family: var(--font-display);
  font-weight:800;
  letter-spacing:.08em;
  color:#fff;
  font-size:clamp(1rem,2.6vw,1.35rem);
}

/* Optional responsive tweak, mirrors your sample without Tailwind */
@media (max-width:768px){
  .title-chip{ padding:.4rem .75rem; }
  .title-chip-text{ letter-spacing:.09em; }
}
@media (min-width:768px){
  .title-chip-text{ font-size:1.35rem; } /* matches clampâ€™s max */
}

/* Layout helpers used by the page */
/* Keep hero flush under fixed nav (hide the 1px inset line) */
main{
  /* 1px upward overlap to kill rounding sliver on DPR 2/3 */
  padding-top: calc(var(--nav-height) + env(safe-area-inset-top) - 1px);
}
.wrap {
  max-width:960px;
  margin:0 auto;
  padding:16px;
}
/* REMOVED .wrap--flush to simplify structure. The horizontal gap fix requires this. */
.card {
  background:#14161c;
  border:1px solid #222;
  border-radius:12px;
  padding:16px;
  margin:16px;
}
  footer {
    color:var(--muted);
    text-align:center;
    padding:24px;
    border-top:1px solid #222;
    font-size:.82rem;
  }

  /* Desktop footer lock + runway (Row C centering without desktop spacer math) */
  #footer-lock-sentinel{ height:1px; }
  #footer-placeholder{ height:0px; }
  #desktop-bottom-runway{ height:0px; }

  footer.footer--locked{
    position:fixed;
    left:0;
    right:0;
    bottom:0;
    z-index:300;
    background:#000;
  }
  #mobile-bottom-spacer{
    --mobile-bottom-spacer-height: 0px;
    height: var(--mobile-bottom-spacer-height);
    transition:height .2s ease;
  }
  .footer-nav{
    margin-top:6px;
    display:flex;
    flex-wrap:wrap;
    justify-content:center;
    gap:4px 10px;
    font-size:.78rem;
  }
  .footer-nav-link{
    position:relative;
    color:var(--muted);
    text-decoration:none;
    transition:color .16s ease, opacity .16s ease;
  }
  .footer-nav-link:hover{
    color:var(--fg);
  }
  .footer-nav-link::before{
    content:"â€¢";
    opacity:.6;
    margin:0 6px 0 2px;
  }
  .footer-nav-link:first-child::before{
    content:"";
    margin:0;
  }
  button.cta {
    background:var(--accent);
    color:#0b1020;
    border:0;
    padding:10px 14px;
    border-radius:10px;
    font-weight:600;
    cursor:pointer;
  }
  button.cta:focus {
    outline:2px solid #fff4;
    outline-offset:2px;
  }
  h1 { font-size:clamp(28px,4vw,40px); margin:0 0 8px; }
  h2 { font-size:clamp(18px,4.5vw,24px); margin:12px 0 8px; }
  p  { margin:8px 0; color:var(--muted); }

/* HERO */
.hero{
  position:relative;
  height:auto;
  aspect-ratio:16 / 9;
  overflow:hidden;             /* crops the overfill from the iframe */
  background:#000;
  width:170vw;
  left:50%;
  transform: translateX(-50%);
  z-index:1;
  margin-top:-2px;             /* touch the nav */
  border-top:0;
}

.hero-video { position:absolute; inset:0; opacity:1; transition: opacity 400ms ease; }
.hero-video.is-hero-fadeout{ opacity:0; }

/* Cover + crop bottom WITHOUT clip-path */
.hero-video iframe{
  position:absolute;
  inset:0;
  width:170vw;
  height:112%;                 /* overfill vertically */
  left:50%;
  transform:translate(-50%, -6%); /* shift up to crop bottom */
  border:0;
}

/* Black spacer under the hero - NOW RESPONSIBLE FOR FULL WIDTH COVERAGE */
.after-hero{
  min-height:0; /* reduced to remove large gap below Row A */
  background:#000;
  border:0;
  margin:0;
  border-radius:0;
  padding:0; /* Ensure no padding on the .after-hero so the black background is full width */
  margin-top:0; /* pull pills closer to synopsis */
}

/* New wrapper to correctly apply padding and center content within the full-width black section */
.content-pad {
  max-width:960px;
  margin:0 auto;
  /* Apply responsive padding only to the content wrapper */
  padding: 0 calc(16px + env(safe-area-inset-right)) 16px calc(16px + env(safe-area-inset-left));
}


/* Hero gradient: bottom â†’ top, covers full hero */
.hero-gradient{
  position:absolute;
  inset:0;                    /* cover full hero box */
  z-index:1;                  /* video (0) < gradient (1) < overlay (2) */
  pointer-events:none;
  transform:translateZ(0);
  backface-visibility:hidden;
  background:linear-gradient(
    to top,
    rgba(0,0,0,0.88) 0%,
    rgba(0,0,0,0.76) 10%,
    rgba(0,0,0,0.60) 22%,
    rgba(0,0,0,0.42) 36%,
    rgba(0,0,0,0.26) 52%,
    rgba(0,0,0,0.14) 68%,
    rgba(0,0,0,0.00) 100%
  );
}

@media (max-width:600px){
  .hero-gradient{
    background:linear-gradient(
      to top,
      rgba(0,0,0,0.92) 0%,
      rgba(0,0,0,0.80) 12%,
      rgba(0,0,0,0.64) 26%,
      rgba(0,0,0,0.46) 40%,
      rgba(0,0,0,0.28) 56%,
      rgba(0,0,0,0.14) 72%,
      rgba(0,0,0,0.00) 100%
    );
  }
}

.hero-text {
  padding:64px 0;
  display:grid;
  gap:16px;
}
@media (max-width:600px) {
  .hero-text { padding:48px 0; }
}

  /* Apply drop shadow to all overlay text */
.hero-overlay-inline,
.hero-overlay-inline * {
  text-shadow: 0 1px 3px rgba(0,0,0,0.70);
}

/* Stronger shadow for the synopsis for readability */
.hero-overlay-inline .hero-synopsis {
  text-shadow: 0 2px 6px rgba(0,0,0,0.85);
}

/* Mute button */
  .mute-btn {
    width:40px;
    height:40px;
    border-radius:999px;
    border:1px solid #222;
    background:#121212;
    color:#eaeaf0;
    display:grid;
    place-items:center;
    font-size:18px;
    cursor:pointer;
  }
  .mute-btn:focus {
    outline:2px solid #fff4;
    outline-offset:2px;
  }
  /* commit: no-horizontal-scroll */
html { overflow-x: hidden; }
/* ZAQ TASK â€” PREVIEW SCROLL LOCK: reserve scrollbar space to prevent layout shift */
html { scrollbar-gutter: stable; }

/* CTA row under the hero video */
.hero-cta{
  display:flex;
  gap:8px;
  width:100%;
  max-width:420px;                   /* keep pills on one line */
  margin: calc(8px + .125rem) 0 0 0; /* FIXED gap below synopsis */
  align-items:center;
}
.hero-cta .btn {
  flex:1 1 0;
}
.hero-cta .mute-btn {
  flex:0 0 auto;
}
.hero-cta-anchor{
  margin: calc(8px + .125rem) 0 0 0;
  min-height:36px;
}
.hero-cta-layer{
  position:absolute;
  z-index:10000;
  left:0;
  top:0;
  pointer-events:auto;
  will-change: transform;
  opacity:0;
  transition: opacity 120ms ease;
}
.hero-cta-layer.is-positioned{
  opacity:1;
}
.hero-cta-layer .hero-cta{
  margin:0;
}

/* Smaller buttons */
.btn{
  appearance:none; border:0; cursor:pointer;
  display:inline-flex; align-items:center; justify-content:center;
  gap:.35rem; padding:.42rem .56rem; border-radius:999px; /* same height, narrower */
  font:700 .80rem/1 var(--font-ui);
  transition:transform .12s ease, opacity .12s ease, box-shadow .12s ease, background .12s ease;
  width:100%;
  box-shadow: 0 6px 14px rgba(0,0,0,.18);
}
.btn:focus{ outline:2px solid #ffffff33; outline-offset:2px; }
.btn:active{ transform: translateY(1px); }

.btn--solid{ background:#fff; color:#000; }
.btn--solid:hover{ background:#e6e6e6; }

.btn--ghost{
  background: rgba(255,255,255,0.10); color:#fff;
  box-shadow: inset 0 0 0 1.1px rgba(255,255,255,0.28);
}
.btn--ghost:hover{ box-shadow: inset 0 0 0 1.1px rgba(255,255,255,0.5); }

/* Smaller icons */
.btn svg{ width:14px; height:14px; display:block; } /* matches reduced height */
.btn--solid:hover{ background:#e6e6e6; }

.btn--ghost{
  background: rgba(255,255,255,0.10); color:#fff;
  box-shadow: inset 0 0 0 1.25px rgba(255,255,255,0.28);
}
.btn--ghost:hover{ box-shadow: inset 0 0 0 1.25px rgba(255,255,255,0.5); }

/* Smaller icons */
.btn svg{ width:16px; height:16px; display:block; }

/* REMOVED: ALWAYS-ON GAP CHECK BACKGROUND */
/* =============================
   Shelves (Rows A/B/C)
   ============================= */
:root{ --shelf-gap:4px; --shelf-radius:14px; }
.shelf{ margin:0; }
.shelf-title{ font:700 1rem/1.3 var(--font-ui); color:var(--fg); margin:0 0 6px; position:relative; transform:translateY(var(--shelf-title-shift-mobile)); }
.shelf-divider{ height:2px; background:#3a3f46; opacity:.9; border-radius:2px; }
/* Full-bleed wrapper so the track can extend to viewport edges */
.shelf-outer{ position:relative; width:100vw; left:50%; transform:translateX(-50%); }
/* Edge fades (narrow 48px) */
.shelf-outer::before, .shelf-outer::after{
  content:""; position:absolute; top:0; bottom:0; width:120px; pointer-events:none; z-index:2;
}
.shelf-outer::before{
  left:0;
  background:linear-gradient(
    to right,
    rgba(0,0,0,1) 0%,
    rgba(0,0,0,0.88) 20%,
    rgba(0,0,0,0.60) 45%,
    rgba(0,0,0,0.32) 75%,
    rgba(0,0,0,0.00) 100%
  );
}
.shelf-outer::after{
  right:0;
  background:linear-gradient(
    to left,
    rgba(0,0,0,1) 0%,
    rgba(0,0,0,0.88) 20%,
    rgba(0,0,0,0.60) 45%,
    rgba(0,0,0,0.32) 75%,
    rgba(0,0,0,0.00) 100%
  );
}
/* Horizontal list of posters */
/* --- SHELF TRACK --- */
/* Add scroll-snapping and hide the scrollbar */
.shelf-track {
  display: grid;
  grid-auto-flow: column;
  gap: var(--shelf-gap);
  overflow-x: auto;
  overscroll-behavior-x: contain;
  -webkit-overflow-scrolling: touch;
  padding: 10px calc(16px + env(safe-area-inset-right)) 16px calc(16px + env(safe-area-inset-left));
  scroll-snap-type: x mandatory; /* Snap horizontally */
  scrollbar-width: none; /* Hide scrollbar for Firefox */
  cursor: grab;
  position: relative;
  z-index: 0;
}
.shelf-track::-webkit-scrollbar {
  display: none; /* Hide scrollbar for Chrome, Safari, Opera */
}
.shelf-track[role="list"] { list-style: none; }

.shelf-track.is-dragging {
  cursor: grabbing;
  user-select: none;
}

@media (pointer: fine) {
  .shelf-track {
    scroll-snap-type: none;
  }
}

/* --- POSTER --- */
/* Add snap alignment, transitions, and a transform origin */
.poster {
  position: relative;
  display: block;
  background: #1e2228;
  border: 1px solid #2a2f36;
  border-radius: var(--shelf-radius);
  overflow: hidden;
  aspect-ratio: 2 / 3;
  width: calc((100vw - (16px * 2) - (var(--shelf-gap) * 2)) / 3); /* ~3.0 visible on mobile */
  scroll-snap-align: center; /* Snap posters to the center */
  transform-origin: center center;
  filter: brightness(0.9);
  opacity: 0.8;
  /* Animate all the properties we change on the active state */
  transition: transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
              box-shadow 0.35s cubic-bezier(0.25, 0.1, 0.25, 1),
              border-color 0.35s ease,
              filter 0.35s ease,
              opacity 0.35s ease;
  z-index: 1; /* Default stacking level */
}


.preview-morph-tile {
  position: fixed;
  top: 0;
  left: 0;
  transform-origin: top left;
  pointer-events: none;
  z-index: 20000;
  background: #05060a;
  overflow: hidden;
  border: var(--preview-frame-border);
  border-radius: var(--preview-frame-radius);
  box-shadow: var(--preview-frame-shadow);
  transition:
    transform var(--preview-morph-duration) var(--preview-morph-ease),
    width var(--preview-morph-duration) var(--preview-morph-ease),
    height var(--preview-morph-duration) var(--preview-morph-ease),
    opacity 0.24s ease,
    border-radius var(--preview-morph-duration) var(--preview-morph-ease),
    box-shadow var(--preview-morph-duration) var(--preview-morph-ease),
    border-color var(--preview-morph-duration) var(--preview-morph-ease);
  will-change: transform, opacity, width, height, border-radius;
  backface-visibility: hidden;
  transform: translate3d(0,0,0);
}

.preview-morph-fill {
  position: absolute;
  inset: 0;
  background: #000;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  opacity: 1;
  transition: opacity var(--preview-morph-duration) var(--preview-morph-ease);
  backface-visibility: hidden;
}

.preview-morph-tile.is-fade-out {
  opacity: 0;
}

.preview-morph-fill.is-fade-out {
  opacity: 0;
}

.poster img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: inherit;
  -webkit-user-drag: none;
  user-select: none;
  pointer-events: none;
}

/* Style the active/centered poster to give it scale and depth */
/* Base active state: quiet red border, no neon glow */
.poster.is-active {
  border-width: 2px;
  border-style: solid;
  border-color: color-mix(in srgb, var(--brand) 55%, #2a2f36 45%);
  box-shadow: none;
  filter: brightness(1.0);
  opacity: 1;
  z-index: 2; /* Ensures the active card renders on top of its neighbors */
}

/* Row-activated neon: only when the shelf-track is active */
.shelf-track--active .poster.is-active {
  border-color: var(--brand);
  box-shadow: var(--brand-glow-shadow);
  filter: brightness(1.08);
  opacity: 1;
}

.hero--active .hero-cta .btn--solid,
.hero.hero--active + .hero-cta-layer .hero-cta .btn--solid {
  outline: 2px solid var(--brand);
  box-shadow: var(--brand-glow-shadow), 0 6px 14px rgba(0,0,0,.18);
}

/* Make the poster label visible and styled */
.poster::after {
  content: attr(data-label);
  position: absolute;
  inset: auto 0 10px 0; /* Center the text horizontally near the bottom */
  color: #fff;
  font: 700 1.25rem/1 var(--font-ui);
  text-align: center;
  text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  opacity: 0.8;
  pointer-events: none; /* Ensure it doesn't interfere with clicks */
}
/* Desktop provisional */
@media (min-width:768px){ .poster{ width:140px; } }
/* Spacing tweaks */
.shelf--tight{ margin-top:8px; }
.content-pad--tight{ padding-bottom:8px; }
/* First shelf sits tighter under CTA */
.shelf--tight{ margin-top:8px; }

.hero-debug{
  display:none;
}

@media (min-width:1024px){
  /* Desktop: wider content and cinematic layout */
  .content-pad {
    max-width: 1280px;
    padding: 0 40px 24px 40px;
  }

  .hero-overlay-inline{
    padding-left: 40px !important;
    padding-right: 40px !important;
  }

  .hero-text {
    padding: 96px 0;
  }

  .shelf {
    margin: 0;
  }

  /* Desktop: pull Row A shelf (only) closer to the hero so that
     the top edge of the Row A posters aligns with the bottom edge
     of the hero video box. This moves Row A as a block without
     affecting Rows B and C. */
  .after-hero .shelf.shelf--tight {
    margin-top: 0.40rem;        /* Pills â†’ Row A label rhythm on desktop */
  }

  .hero-cta {
    max-width: 520px;
    margin-top: 0.40rem;
    margin-left: 0;
  }

  .btn {
    font-size: 0.95rem;
    padding: 0.50rem 0.80rem;
  }

  .poster {
    width: 200px;
  }

  /* Desktop: hero/video fills viewport width */
  .hero {
    width: 100vw;
    height: 80vh;
    max-height: 80vh;
    left: 0;
    transform: none;
    aspect-ratio: auto;
  }

    /* Desktop-only debug overlay grid */
  body.debug-layout .hero-debug{
    display:block;
    position:absolute;
    inset:0;
    z-index:3;
    pointer-events:none;
    background:transparent;
    background-image:
      linear-gradient(rgba(255,47,155,0.8) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,47,155,0.8) 1px, transparent 1px);
    background-size: calc(100%/6) calc(100%/4);
  }

  .after-hero{
    position:relative;
    z-index:3;
    margin-top: -16vh;   /* counter the extra hero height */
    background: transparent;
  }

  /* Desktop: add spacer padding so Row A cards sit on the same
     horizontal line as the bottom edge of the hero video box. */
  .after-hero{
    padding-top: 1.35rem; /* ZAQ TASK 03: lifted shelves so Row A aligns with hero text bottom */
  }


  .hero-overlay-inline{
    padding-left: 40px !important;
    padding-right: 40px !important;
    bottom:14vh !important;
    padding-bottom:0 !important;
  }

  .hero-synopsis{
    margin-bottom:0 !important;
  }


  .hero-gradient{
    background:linear-gradient(
      to top,
      rgba(0,0,0,0.98) 0%,
      rgba(0,0,0,0.92) 14%,
      rgba(0,0,0,0.78) 30%,
      rgba(0,0,0,0.56) 46%,
      rgba(0,0,0,0.32) 64%,
      rgba(0,0,0,0.16) 82%,
      rgba(0,0,0,0.00) 100%
    );
  }

  .hero-overlay-inline{
    left:0;
    padding-left:calc(var(--space-synopsis-pills) + env(safe-area-inset-left)) !important;
  }

  .shelf-title{
    margin-left:0;
    margin-bottom:0.32rem;
  }

  .shelf-track{
    padding: 24px 40px 24px 40px;
  }

  /* Desktop: remove extra top padding above Row A posters so their
     top edges can sit flush with the hero bottom line. */
  .after-hero .shelf.shelf--tight .shelf-track {
    padding-top: 24px;      /* align Row A posters with global desktop shelf padding */
  }
}


@media (min-width:1024px){
  /* Desktop: make iframe 16:9 and full viewport width, anchored to bottom of hero */
  .hero-video iframe{
    position:absolute;
    left:50%;
    top:50%;
    bottom:auto;
    right:auto;
    width:100vw;
    height:calc(100vw * 9 / 16);
    transform:translate(-50%, -50%);
  }
}


@media (min-width: 1024px) {
  /* Desktop-only debug outlines */

  body.debug-layout .hero {
    outline: 2px solid rgba(255, 0, 0, 0.8); /* red */
  }

  body.debug-layout .hero-overlay-wrap {
    outline: 2px solid rgba(0, 128, 255, 0.9); /* blue */
  }

  body.debug-layout .after-hero {
    outline: 2px solid rgba(0, 200, 120, 0.9); /* green */
    background-color: rgba(0, 200, 120, 0.06);
  }

  body.debug-layout .shelf {
    outline: 2px dashed rgba(255, 165, 0, 0.9); /* orange */
  }

  body.debug-layout .shelf-outer {
    outline: 2px solid rgba(255, 255, 0, 0.8); /* yellow */
    background-color: rgba(255, 255, 0, 0.04);
  }

  body.debug-layout .shelf-track {
    outline: 2px solid rgba(186, 85, 211, 0.9); /* purple */
    background-color: rgba(186, 85, 211, 0.04);
  }

  body.debug-layout .poster {
    outline: 2px solid rgba(0, 255, 255, 0.9); /* cyan */
  }

  body.debug-layout .poster.is-active {
    outline: 3px solid rgba(255, 255, 255, 0.95); /* white, stronger */
  }
}


@media (min-width: 1024px) {
  /* Desktop-only debug outlines: hero text + inner content container */
  body.debug-layout .hero-overlay-inline {
    outline: 2px solid rgba(255, 105, 180, 0.9); /* pink */
  }

  body.debug-layout .content-pad {
    outline: 2px solid rgba(173, 216, 230, 0.9); /* light blue */
  }
}

:root {
  /* Hero + Row A spacing tokens, aligned to a 4px-based grid (comments only) */
  --space-chip-meta: 0.5rem;      /* â‰ˆ 8px  = 2 Ã— 4px  (Chip â†’ Meta) */
  --space-synopsis-pills: 2.20rem;/* â‰ˆ 35px â‰ˆ 9 Ã— 4px (Synopsis â†’ Pills) */
  --space-pills-rowa: 0.40rem;    /* â‰ˆ 6px  â‰ˆ 1.5 Ã— 4px (Pills â†’ Row A label) */
  --space-rowa-divider: 0.20rem;  /* â‰ˆ 3px  â‰ˆ 0.75 Ã— 4px (Row A label â†’ divider) */

  /* ZAQ â€“ shelf label vertical offsets */
  --shelf-title-shift-mobile: 2rem;    /* shift labels into gap below divider on mobile/tablet */
  --shelf-title-shift-desktop: 2.25rem;/* slightly larger shift for desktop gap */
}

/* ZAQ â€“ desktop-only vertical rhythm for hero + Row A */
@media (min-width: 1024px) {
  .title-chip {
    margin-bottom: var(--space-chip-meta);       /* Chip â†’ Meta */
  }

  .hero-cta {
    margin-top: var(--space-synopsis-pills);     /* Synopsis â†’ Pills */
  }

  .shelf.shelf--tight {
    margin-top: var(--space-pills-rowa);         /* Pills â†’ Row A Label */
  }

  .shelf-title {
    margin-bottom: var(--space-rowa-divider);    /* Row A Label â†’ Divider */
    transform: translateY(var(--shelf-title-shift-desktop));
  }
}

  /* =============================
     Preview Overlay (Static Layout)
     ============================= */
  .preview-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, rgba(0,0,0,0.80), rgba(0,0,0,0.95));
    z-index: 20000;
    padding: 16px;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity var(--preview-morph-duration) var(--preview-morph-ease), visibility 0s linear var(--preview-morph-duration);
  }

  /* Future: when we add JS, weâ€™ll toggle this class */
  .preview-overlay.is-visible {
    z-index: 20000;
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transition: opacity var(--preview-morph-duration) var(--preview-morph-ease);
  }

  .preview-card {
    width: 100%;
    max-width: 960px;
    max-height: 90vh;
    background: #05060a;
    border-radius: var(--preview-frame-radius);
    border: var(--preview-frame-border);
    box-shadow: var(--preview-frame-shadow);
    overflow: hidden;
    display: grid;
    grid-template-rows: auto 1fr;
    position: relative;
    opacity: 0;
    transition:
      transform var(--preview-morph-duration) var(--preview-morph-ease),
      opacity var(--preview-morph-duration) var(--preview-morph-ease);
  }

  .preview-card.is-active {
    opacity: 1;
  }

  .preview-card.is-hidden {
    opacity: 0;
    pointer-events: none;
  }

  .preview-close-btn {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 36px;
    height: 36px;
    display: inline-grid;
    place-items: center;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(0,0,0,0.55);
    color: #fff;
    font-size: 1.1rem;
    font-weight: 700;
    cursor: pointer;
  }

  .preview-close-btn:hover {
    background: rgba(255,255,255,0.10);
  }

  .preview-media {
    position: relative;
    background: #000;
    aspect-ratio: 16 / 9;
  }

  .preview-media-placeholder {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(circle at top, rgba(255,255,255,0.10), transparent 55%),
      linear-gradient(135deg, #222632, #11131a);
  }

  .preview-info {
    padding: 16px 18px 18px 18px;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 12px;
  }

  .preview-header {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .preview-title {
    font-family: var(--font-display);
    font-size: 1.2rem;
    font-weight: 800;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    margin: 0;
  }

  .preview-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    font-size: 0.78rem;
    color: var(--muted);
  }

  .preview-runtime {
    padding: 2px 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    font-weight: 600;
  }

  .preview-tags {
    opacity: 0.9;
  }

  .preview-body {
    font-size: 0.88rem;
    color: var(--muted);
    overflow: auto;
  }

  .preview-description {
    margin: 0;
  }

  .preview-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: flex-start;
  }

  .preview-play-button,
  .preview-details-button {
    appearance: none;
    border-radius: 999px;
    padding: 8px 14px;
    font: 700 0.85rem/1 var(--font-ui);
    cursor: pointer;
    border: 0;
    transition: background 0.16s ease, transform 0.12s ease, box-shadow 0.16s ease;
  }

  .preview-play-button {
    background: #fff;
    color: #000;
    box-shadow: 0 12px 32px rgba(0,0,0,0.55);
  }

  .preview-play-button:hover {
    background: #f0f0f0;
    transform: translateY(1px);
  }

  .preview-details-button {
    background: rgba(255,255,255,0.06);
    color: #eaeaf0;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.15);
  }

  .preview-details-button:hover {
    background: rgba(255,255,255,0.10);
  }

  @media (max-width: 640px) {
    .preview-card {
      max-width: 100%;
      border-radius: var(--preview-frame-radius);
      max-height: 100vh;
    }

    .preview-info {
      padding: 14px 14px 16px 14px;
    }
  }

  @media (min-width: 641px) {
    .preview-card {
      max-height: calc(100vh - 32px);
    }
  }


  /* =============================
     Poster Preview Button (A1 only)
     ============================= */
  .poster-preview-button {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    padding: 6px 14px;
    font-size: 0.75rem;
    font-family: var(--font-ui);
    font-weight: 700;
    text-transform: uppercase;
    border-radius: 999px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.25);
    color: #fff;
    backdrop-filter: blur(6px);
    cursor: pointer;
    transition: opacity 0.25s ease, transform 0.25s ease;
    opacity: 1;            /* always visible for now */
    pointer-events: auto;  /* clickable */
  }

  .poster-preview-button:hover {
    background: rgba(255,255,255,0.20);
    transform: translateX(-50%) scale(1.05);
  }

</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
  <header class="nav-bar" role="navigation" aria-label="Main">
    <div class="nav-inner">
      <a class="brand" href="/" aria-label="Home">SanchezNinjah</a>
      <nav class="nav-links" aria-label="Primary">
        <a class="nav-link nav-link--active" href="#hero" aria-label="Go to Film section" aria-current="page">Film</a>
        <a class="nav-link" href="#photography" aria-label="Go to Photography section">Photography</a>
        <a class="nav-link" href="#social-media" aria-label="Go to Social Media section">Social Media</a>
        <a class="nav-link" href="#side-quests" aria-label="Go to Side Quests section">Side Quests</a>
        <a class="nav-link" href="#about" aria-label="Go to About section">About</a>
        <a class="nav-link" href="#contact" aria-label="Go to Contact section">Contact</a>
      </nav>
      <div class="nav-actions">
        <button class="icon-btn" aria-label="Search">
          <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true"><path d="M10.5 3a7.5 7.5 0 015.92 12.2l3.69 3.69-1.42 1.42-3.69-3.69A7.5 7.5 0 1110.5 3zm0 2a5.5 5.5 5.5 0 100 11 5.5 5.5 0 000-11z"/></svg>
        </button>
        <button class="icon-btn" aria-label="Notifications">
          <span class="dot" aria-hidden="true"></span>
          <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a4 4 0 00-4 4v1.1C6.2 8 5 9.7 5 11.6V17l-1.5 1.5v1h17v-1L19 17v-5.4c0-1.9-1.2-3.6-3-4.5V6a4 4 0 00-4-4zm0 20a3 3 0 01-3-3h6a3 3 0 01-3 3z"/></svg>
        </button>
        <button class="icon-btn" id="debugToggleButton" type="button" aria-label="Toggle layout debug" aria-pressed="false">Debug</button>
      </div>
    </div>
  </header>
  <main>
<section class="hero hero--active" id="hero">
  <div class="hero-video">
    <iframe
      id="hero-yt"
      title="Hero trailer"
      src="https://www.youtube.com/embed/t1x7Q0IA3Os?autoplay=1&mute=1&playsinline=1&controls=0&loop=1&modestbranding=1&rel=0&enablejsapi=1&playlist=t1x7Q0IA3Os&start=0"
      allow="autoplay; encrypted-media"
      allowfullscreen
    ></iframe>
    <div class="hero-debug" aria-hidden="true"></div>
  </div>

  <!-- Hero gradient: bottom â†’ top -->
  <div class="hero-gradient" aria-hidden="true"></div>

  <!-- Overlay area locked to viewport edges -->
  <div class="hero-overlay-wrap"
       style="position:absolute;top:0;bottom:0;
              left:calc((100% - 100vw)/2);
              right:calc((100% - 100vw)/2);
              z-index:11000;display:flex;flex-direction:column;
              justify-content:flex-end;pointer-events:auto;overflow:hidden;">
    <div class="hero-overlay-inline"
         style="pointer-events:auto;position:absolute;bottom:0;left:0;
                max-width:720px;color:#fff;text-align:left;
                padding:12px calc(16px + env(safe-area-inset-right)) 0 calc(16px + env(safe-area-inset-left));
                text-shadow:0 1px 3px rgba(0,0,0,.5);
                background:transparent;border-radius:12px 12px 0 0;">
<div class="title-chip" role="heading" aria-level="1">
  <span class="title-chip-text">Sanchez Ninjah</span>
</div>

<p id="meta-line" style="margin:0 0 .14rem;color:var(--brand);
                font-size:clamp(.78rem,1.6vw,.95rem);
                font-weight:700;letter-spacing:.08em;text-transform:uppercase;">
  New Release | Thriller, Sci-Fi | 2024
</p>

      <p class="hero-synopsis" style="margin:0;color:#e5e7eb;
                font-size:clamp(.95rem,2.2vw,1.15rem);line-height:1.55;
                display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;
                overflow:hidden;">
        As a rogue AI network threatens global collapse, a disgraced former agent is called
        back into the field for one last, impossible mission to save humanity.
      </p>
      <div class="hero-cta-anchor" aria-hidden="true"></div>
    </div>
  </div>

</section>
  <div class="hero-cta-layer" aria-label="Hero actions">
    <div class="hero-cta">
      <!-- Play Now -->
      <button type="button" class="btn btn--solid">
        <svg aria-hidden="true" focusable="false" viewBox="0 0 20 20" fill="currentColor">
          <path d="M6 4l10 6-10 6V4z"/>
        </svg>
        <span>Play Now</span>
      </button>

      <!-- Details -->
      <button type="button" class="btn btn--ghost hero-details-button">
        <svg aria-hidden="true" focusable="false" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M13 16h-1v-4h-1m1-4h.01"/>
          <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
        <span>Details</span>
      </button>
      <button class="mute-btn" type="button" aria-pressed="true" onclick="toggleMute()" aria-label="Mute or unmute">ðŸ”‡</button>
    </div>
  </div>
<!-- This wrapper div was limiting the width and causing the pink background to leak. -->
<!-- OLD: <div class="wrap wrap--flush"> -->
<section class="after-hero" aria-label="Actions">
  <!-- Use a new inner wrapper to apply max-width and centering for content -->

  <!-- Row A moved inside after-hero -->
  <section class="shelf shelf--tight" aria-labelledby="row-a-title">
    <div class="content-pad">
      <h2 id="row-a-title" class="shelf-title">Row A</h2>
      <div class="shelf-divider" aria-hidden="true"></div>
    </div>
    <div class="shelf-outer">
      <div class="shelf-track" data-row="A" role="list" aria-label="Row A posters">
        <a class="poster" role="listitem" aria-label="A1" data-label="A1" data-title="TBD Title A1" data-description="TBD Description A1" data-runtime="TBD Runtime A1" data-tags="TBD Tags A1" data-youtube-url="TBD YouTube URL A1" data-poster-vert="images/poster-vert-A1.png" data-poster-wide="images/poster-wide-A1.png" data-morph-id="morph-01"><img src="images/poster-vert-A1.png" alt="Sanchez Ninjah A1 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A2" data-label="A2" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A2.png" data-poster-wide="images/poster-wide-A2.png" data-morph-id="morph-02"><img src="images/poster-vert-A2.png" alt="A2 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A3" data-label="A3" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A3.png" data-poster-wide="images/poster-wide-A3.png" data-morph-id="morph-03"><img src="images/poster-vert-A3.png" alt="A3 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A4" data-label="A4" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A4.png" data-poster-wide="images/poster-wide-A4.png" data-morph-id="morph-04"><img src="images/poster-vert-A4.png" alt="A4 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A5" data-label="A5" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A5.png" data-poster-wide="images/poster-wide-A5.png" data-morph-id="morph-05"><img src="images/poster-vert-A5.png" alt="A5 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A6" data-label="A6" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A6.png" data-poster-wide="images/poster-wide-A6.png" data-morph-id="morph-06"><img src="images/poster-vert-A6.png" alt="A6 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A7" data-label="A7" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A7.png" data-poster-wide="images/poster-wide-A7.png" data-morph-id="morph-07"><img src="images/poster-vert-A7.png" alt="A7 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A8" data-label="A8" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A8.png" data-poster-wide="images/poster-wide-A8.png" data-morph-id="morph-08"><img src="images/poster-vert-A8.png" alt="A8 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A9" data-label="A9" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A9.png" data-poster-wide="images/poster-wide-A9.png" data-morph-id="morph-09"><img src="images/poster-vert-A9.png" alt="A9 poster"><button class="poster-preview-button" type="button">Preview</button></a>
        <a class="poster" role="listitem" aria-label="A10" data-label="A10" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A10.png" data-poster-wide="images/poster-wide-A10.png" data-morph-id="morph-10"><img src="images/poster-vert-A10.png" alt="A10 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      </div>
    </div>
  </section>
</section>
<!-- Shelves: titles in container, cards full-bleed -->

<section class="shelf" aria-labelledby="row-b-title">
  <div class="content-pad">
    <h2 id="row-b-title" class="shelf-title">Row B</h2>
    <div class="shelf-divider" aria-hidden="true"></div>
  </div>
  <div class="shelf-outer">
    <div class="shelf-track" data-row="B" role="list" aria-label="Row B posters">
      <a class="poster" role="listitem" aria-label="B1" data-label="B1" data-title="TBD Title B1" data-description="TBD Description B1" data-runtime="TBD Runtime B1" data-tags="TBD Tags B1" data-youtube-url="TBD YouTube URL B1" data-poster-vert="images/poster-vert-A1.png" data-poster-wide="images/poster-wide-A1.png" data-morph-id="morph-11"><img src="images/poster-vert-A1.png" alt="B1 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B2" data-label="B2" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A2.png" data-poster-wide="images/poster-wide-A2.png" data-morph-id="morph-12"><img src="images/poster-vert-A2.png" alt="B2 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B3" data-label="B3" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A3.png" data-poster-wide="images/poster-wide-A3.png" data-morph-id="morph-13"><img src="images/poster-vert-A3.png" alt="B3 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B4" data-label="B4" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A4.png" data-poster-wide="images/poster-wide-A4.png" data-morph-id="morph-14"><img src="images/poster-vert-A4.png" alt="B4 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B5" data-label="B5" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A5.png" data-poster-wide="images/poster-wide-A5.png" data-morph-id="morph-15"><img src="images/poster-vert-A5.png" alt="B5 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B6" data-label="B6" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A6.png" data-poster-wide="images/poster-wide-A6.png" data-morph-id="morph-16"><img src="images/poster-vert-A6.png" alt="B6 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B7" data-label="B7" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A7.png" data-poster-wide="images/poster-wide-A7.png" data-morph-id="morph-17"><img src="images/poster-vert-A7.png" alt="B7 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B8" data-label="B8" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A8.png" data-poster-wide="images/poster-wide-A8.png" data-morph-id="morph-18"><img src="images/poster-vert-A8.png" alt="B8 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B9" data-label="B9" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A9.png" data-poster-wide="images/poster-wide-A9.png" data-morph-id="morph-19"><img src="images/poster-vert-A9.png" alt="B9 poster"><button class="poster-preview-button" type="button">Preview</button></a>
      <a class="poster" role="listitem" aria-label="B10" data-label="B10" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-A10.png" data-poster-wide="images/poster-wide-A10.png" data-morph-id="morph-20"><img src="images/poster-vert-A10.png" alt="B10 poster"><button class="poster-preview-button" type="button">Preview</button></a>
    </div>
  </div>
</section>

<section class="shelf" aria-labelledby="row-c-title">
  <div class="content-pad">
    <h2 id="row-c-title" class="shelf-title">Row C</h2>
    <div class="shelf-divider" aria-hidden="true"></div>
  </div>
  <div class="shelf-outer">
    <div class="shelf-track" data-row="C" role="list" aria-label="Row C posters">
      <a class="poster" role="listitem" aria-label="C1" data-label="C1" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C1.png" data-poster-wide="images/poster-wide-C1.png"></a>
      <a class="poster" role="listitem" aria-label="C2" data-label="C2" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C2.png" data-poster-wide="images/poster-wide-C2.png"></a>
      <a class="poster" role="listitem" aria-label="C3" data-label="C3" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C3.png" data-poster-wide="images/poster-wide-C3.png"></a>
      <a class="poster" role="listitem" aria-label="C4" data-label="C4" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C4.png" data-poster-wide="images/poster-wide-C4.png"></a>
      <a class="poster" role="listitem" aria-label="C5" data-label="C5" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C5.png" data-poster-wide="images/poster-wide-C5.png"></a>
      <a class="poster" role="listitem" aria-label="C6" data-label="C6" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C6.png" data-poster-wide="images/poster-wide-C6.png"></a>
      <a class="poster" role="listitem" aria-label="C7" data-label="C7" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C7.png" data-poster-wide="images/poster-wide-C7.png"></a>
      <a class="poster" role="listitem" aria-label="C8" data-label="C8" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C8.png" data-poster-wide="images/poster-wide-C8.png"></a>
      <a class="poster" role="listitem" aria-label="C9" data-label="C9" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C9.png" data-poster-wide="images/poster-wide-C9.png"></a>
      <a class="poster" role="listitem" aria-label="C10" data-label="C10" data-title="" data-description="" data-runtime="" data-tags="" data-youtube-url="" data-poster-vert="images/poster-vert-C10.png" data-poster-wide="images/poster-wide-C10.png"></a>
    </div>
  </div>
</section>
<!-- OLD: </div> -->

  </main>

  <!-- Spacer to add scroll runway without affecting layout when collapsed. -->
  <div id="mobile-bottom-spacer" aria-hidden="true"></div>
  <div id="footer-lock-sentinel" aria-hidden="true"></div>
  <div id="footer-placeholder" aria-hidden="true"></div>
  <footer>
    Â© <span id="y"></span> Rawoul
    <nav class="footer-nav" aria-label="Footer navigation">
      <a class="footer-nav-link footer-nav-link--active" href="#hero" aria-label="Go to Film section">Film</a>
      <a class="footer-nav-link" href="#photography" aria-label="Go to Photography section">Photography</a>
      <a class="footer-nav-link" href="#social-media" aria-label="Go to Social Media section">Social Media</a>
      <a class="footer-nav-link" href="#side-quests" aria-label="Go to Side Quests section">Side Quests</a>
      <a class="footer-nav-link" href="#about" aria-label="Go to About section">About</a>
      <a class="footer-nav-link" href="#contact" aria-label="Go to Contact section">Contact</a>
    </nav>
  </footer>
  <div id="desktop-bottom-runway" aria-hidden="true"></div>
  <script>document.getElementById('y').textContent = new Date().getFullYear();</script>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
  // Changed alerts to console.log as alerts break the canvas environment.
  const HERO_VIDEO_ID = 't1x7Q0IA3Os';
  let ytPlayer, isMuted = true;
  let hasUserGesturePlayback = false;
  window.heroPlaybackRequested = false;
  function isMobilePlayback() {
    return !!(window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
  }
  function isPlayNowHighlighted() {
    const hero = document.querySelector('.hero');
    const playButton = document.querySelector('.hero-cta .btn--solid');
    if (!hero || !playButton) return false;
    return hero.classList.contains('hero--active');
  }
  function canLoopHeroVideo() {
    if (!isPlayNowHighlighted()) return false;
    if (window.snapState && window.snapState.isSnapping) return false;
    if (window.heroLoopState && window.heroLoopState.isScrolling) return false;
    return true;
  }
  function onYouTubeIframeAPIReady(){
    ytPlayer = new YT.Player('hero-yt', {
      playerVars: {
        autoplay: 1,
        mute: 1,
        playsinline: 1,
        controls: 0,
        modestbranding: 1,
        rel: 0,
        start: 0,
        loop: 1,
        playlist: HERO_VIDEO_ID
      },
      events: {
        onReady: e => {
          e.target.mute();
          if (isPlayNowHighlighted()) {
            e.target.playVideo();
          } else {
            e.target.pauseVideo();
          }
        },
        onStateChange: e => {
          if (e.data === YT.PlayerState.PLAYING) {
            hasUserGesturePlayback = true;
            window.heroPlaybackRequested = true;
          }
          if (e.data === YT.PlayerState.PLAYING && !isPlayNowHighlighted()) {
            e.target.pauseVideo();
            return;
          }
          if (e.data === YT.PlayerState.ENDED) {
            e.target.seekTo(0, true);
            if (isPlayNowHighlighted()) {
              e.target.playVideo();
            }
          }
        }
      }
    });
  }
  function toggleMute(){
    if(!ytPlayer) return;
    if(isMuted){ ytPlayer.unMute(); isMuted=false; document.querySelector('.mute-btn').textContent='ðŸ”Š'; document.querySelector('.mute-btn').setAttribute('aria-pressed','false'); }
    else{ ytPlayer.mute(); isMuted=true; document.querySelector('.mute-btn').textContent='ðŸ”‡'; document.querySelector('.mute-btn').setAttribute('aria-pressed','true'); }
  }
  function requestHeroPlayback(){
    const hero = document.querySelector('.hero');
    if (hero) {
      hero.classList.add('hero--active');
    }
    window.heroPlaybackRequested = true;
    if (!ytPlayer) return;
    if (typeof ytPlayer.seekTo === 'function') ytPlayer.seekTo(0, true);
    if (typeof ytPlayer.unMute === 'function') ytPlayer.unMute();
    if (typeof ytPlayer.setVolume === 'function') ytPlayer.setVolume(100);
    ytPlayer.playVideo();
    try {
      const iframe = ytPlayer.getIframe();
      if (iframe) {
        const requestFullscreen = iframe.requestFullscreen || iframe.webkitRequestFullscreen || iframe.mozRequestFullScreen || iframe.msRequestFullscreen;
        if (requestFullscreen) {
          requestFullscreen.call(iframe);
        }
      }
    } catch (_) {}
  }
  document.addEventListener('DOMContentLoaded', () => {
    const hero = document.querySelector('.hero');
    const playButton = document.querySelector('.hero-cta .btn--solid');
    if (playButton) {
      playButton.addEventListener('click', requestHeroPlayback);
    }
    if (hero) {
      hero.addEventListener('click', event => {
        if (!hasUserGesturePlayback && event.target.closest('.hero-overlay-inline, .hero-video')) {
          requestHeroPlayback();
        }
      });
    }
  });
</script>
<script>
  // Make the CTA row 1/3 shorter than its own available width
  (function(){
    let rafId = null;
    function positionCta(){
      const ctaLayer = document.querySelector('.hero-cta-layer');
      const anchor = document.querySelector('.hero-cta-anchor');
      if(!ctaLayer || !anchor) return;

      const anchorRect = anchor.getBoundingClientRect();
      const left = anchorRect.left + window.scrollX;
      const top = anchorRect.top + window.scrollY;

      ctaLayer.style.transform = `translate3d(${left}px, ${top}px, 0)`;
      ctaLayer.classList.add('is-positioned');
    }

    function schedulePositionCta(){
      if (rafId) return;
      rafId = window.requestAnimationFrame(() => {
        rafId = null;
        positionCta();
      });
    }

    function alignCta(){
      const cta = document.querySelector('.hero-cta');
      const anchor = document.querySelector('.hero-cta-anchor');
      if(!cta || !anchor || !anchor.parentElement) return;

      // Use the parentâ€™s current width as the stable base
      const base = anchor.parentElement.getBoundingClientRect().width;

      // Target = 67% of that base (i.e., 1/3 shorter)
      const target = Math.round(base * 0.67);

      // Clamp to keep both pills on one line
      const clamped = Math.max(200, Math.min(target, 420));

      cta.style.width = clamped + 'px';
      anchor.style.height = Math.round(cta.getBoundingClientRect().height) + 'px';
      positionCta();
    }
    window.addEventListener('load', alignCta);
    window.addEventListener('resize', alignCta);
    window.addEventListener('orientationchange', alignCta);
    window.addEventListener('scroll', schedulePositionCta, { passive: true });
  })();
</script>
<script>
  // Press "g" to toggle pink gap debug
  document.addEventListener('keydown', e => {
    if (e.key.toLowerCase() === 'g') document.body.classList.toggle('debug-gap');
  });
  // start disabled
  // document.body.classList.add('debug-gap');
</script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Number of original sets to clone on each side for the infinite effect
    const CLONE_COUNT = 4;
    const RECENTER_DURATION = 1800; // ms, slow cinematic glide
    const activeScrollAnimations = new Map();
    // ZAQ TASK 1 â€” Mobile breakpoint helper (matches existing CSS @media max-width:640px)
    const MOBILE_MQ = window.matchMedia('(max-width: 768px)');
    function isMobileView(){ return !!(MOBILE_MQ && MOBILE_MQ.matches); }
    window.isMobileView = isMobileView;

    let lastActiveTrack = null;
    const heroLoopState = window.heroLoopState || (window.heroLoopState = {
      isScrolling: false,
      scrollTimeout: null
    });

    window.addEventListener('scroll', () => {
      heroLoopState.isScrolling = true;
      if (heroLoopState.scrollTimeout) {
        clearTimeout(heroLoopState.scrollTimeout);
      }
      heroLoopState.scrollTimeout = setTimeout(() => {
        heroLoopState.isScrolling = false;
      }, 180);
    }, { passive: true });

    function cancelScrollAnimation(track) {
      if (!track) return;
      const anim = activeScrollAnimations.get(track);
      if (anim && typeof anim.frameId === 'number') {
        cancelAnimationFrame(anim.frameId);
      }
      activeScrollAnimations.delete(track);
      track.__scrollAnimating = false;
    }

    function animateScrollLeftSlow(track, target, durationMs) {
      if (!track || typeof target !== 'number' || !isFinite(target)) return;

      cancelScrollAnimation(track);

      const start = track.scrollLeft;
      const distance = target - start;

      if (distance === 0 || durationMs <= 0) {
        track.scrollLeft = target;
        return;
      }

      const startTime = performance.now();
      track.__scrollAnimating = true;

      function easeInOutCubic(t) {
        // Extra gentle ease-in-out with zero velocity and acceleration at ends
        // "smootherstep": t^3 * (t * (6t - 15) + 10)
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * t * (t * (6 * t - 15) + 10);
      }

      function step(now) {
        const elapsed = now - startTime;
        let t = elapsed / durationMs;
        if (t < 0) t = 0;
        if (t > 1) t = 1;

        const eased = easeInOutCubic(t);
        track.scrollLeft = start + distance * eased;

        const currentAnim = activeScrollAnimations.get(track);
        if (t < 1 && currentAnim && currentAnim.step === step) {
          const frameId = requestAnimationFrame(step);
          currentAnim.frameId = frameId;
        } else {
          track.scrollLeft = target;
          activeScrollAnimations.delete(track);
          track.__scrollAnimating = false;
        }
      }

      const frameId = requestAnimationFrame(step);
      activeScrollAnimations.set(track, { frameId, step });
    }

    function recenterTrackActivePoster(track) {
      if (!track) return;
      const activePoster = track.querySelector('.poster.is-active');
      if (!activePoster) return;

      const trackWidth = track.clientWidth;
      const activePosterWidth = activePoster.offsetWidth; // Use layout width, not visual width
      const posterLeft = activePoster.offsetLeft;

      const posterCenter = posterLeft + (activePosterWidth / 2);
      const trackCenter = trackWidth / 2;
      const target = posterCenter - trackCenter;

      animateScrollLeftSlow(track, target, RECENTER_DURATION);
    }

    const shelfTracks = Array.from(document.querySelectorAll('.shelf-track'));

    function recenterAllOtherTracks(currentTrack) {
      if (!shelfTracks.length) return;
      for (const track of shelfTracks) {
        if (track === currentTrack) continue;
        if (track.classList.contains('is-dragging')) continue;
        cancelScrollAnimation(track);
        recenterTrackActivePoster(track);
      }
    }

    let windowScrollRaf = null;

    // ZAQ TASK â€” SOFT-PULL VERTICAL ROW CENTERING (REDUCE JUMP)
    const VERTICAL_CENTER_CONFIG = {
      desktop: { settleDelay: 180, duration: 1200, deadzone: 32 }, // ms / ms / px
      mobile: { settleDelay: 240, duration: 1500, deadzone: 24 } // gentler, longer glide
    };
    const REDUCED_MOTION_MQ = window.matchMedia('(prefers-reduced-motion: reduce)');

    function getVerticalCenterConfig() {
      if (REDUCED_MOTION_MQ && REDUCED_MOTION_MQ.matches) return null;
      return isMobileView() ? VERTICAL_CENTER_CONFIG.mobile : VERTICAL_CENTER_CONFIG.desktop;
    }

    let verticalCenterTimeout = null;
    let lastWindowScrollEventAt = 0;
    let pendingVerticalCenterTrack = null;

    let verticalCenterAnim = null; // { frameId, startY, targetY, startTime }

    function cancelVerticalCenterAnimation() {
      if (verticalCenterAnim && typeof verticalCenterAnim.frameId === 'number') {
        cancelAnimationFrame(verticalCenterAnim.frameId);
      }
      verticalCenterAnim = null;
    }

    function easeInOutSmootherStep(t) {
      // "smootherstep": t^3 * (t * (6t - 15) + 10)
      if (t <= 0) return 0;
      if (t >= 1) return 1;
      return t * t * t * (t * (6 * t - 15) + 10);
    }

    function computeVerticalCenterTargetTop(track) {
      const rect = track.getBoundingClientRect();
      const scrollTop = window.scrollY || window.pageYOffset || 0;

      const trackCenterY = (rect.top + scrollTop) + (rect.height / 2);
      const viewportCenterY = scrollTop + (window.innerHeight / 2);

      return scrollTop + (trackCenterY - viewportCenterY);
    }

    function animateWindowScrollToSoft(targetTop, durationMs, deadzone) {
      cancelVerticalCenterAnimation();

      const startY = window.scrollY || window.pageYOffset || 0;
      const delta = targetTop - startY;

      const threshold = typeof deadzone === 'number' ? deadzone : 0;
      if (Math.abs(delta) < threshold || durationMs <= 0) return;

      const startTime = performance.now();

      function step(now) {
        const elapsed = now - startTime;
        let t = elapsed / durationMs;
        if (t < 0) t = 0;
        if (t > 1) t = 1;

        const eased = easeInOutSmootherStep(t);
        const nextY = startY + delta * eased;

        window.scrollTo(0, nextY);

        if (t < 1 && verticalCenterAnim && verticalCenterAnim.step === step) {
          verticalCenterAnim.frameId = requestAnimationFrame(step);
        } else {
          window.scrollTo(0, targetTop);
          cancelVerticalCenterAnimation();
        }
      }

      verticalCenterAnim = { frameId: requestAnimationFrame(step), step, startY, targetY: targetTop, startTime };
    }

    function scheduleVerticalCenterAfterScrollSettles(track) {
      const config = getVerticalCenterConfig();
      if (!config) return;
      pendingVerticalCenterTrack = track;

      if (verticalCenterTimeout) {
        clearTimeout(verticalCenterTimeout);
        verticalCenterTimeout = null;
      }

      const checkAndRun = () => {
        const now = performance.now();
        const sinceLastScroll = now - lastWindowScrollEventAt;

        if (sinceLastScroll < config.settleDelay) {
          verticalCenterTimeout = setTimeout(checkAndRun, config.settleDelay - sinceLastScroll);
          return;
        }

        const t = pendingVerticalCenterTrack;
        pendingVerticalCenterTrack = null;

        if (!t) return;

        const targetTop = computeVerticalCenterTargetTop(t);
        const currentTop = window.scrollY || window.pageYOffset || 0;

        if (Math.abs(targetTop - currentTop) < config.deadzone) return;

        animateWindowScrollToSoft(targetTop, config.duration, config.deadzone);
      };

      verticalCenterTimeout = setTimeout(checkAndRun, config.settleDelay);
    }

    // Cancel immediately on user input while the pull is happening
    const cancelOnUserInput = (e) => {
      // Cancel only on input sources that indicate active user scroll/navigation intent.
      cancelVerticalCenterAnimation();

      if (verticalCenterTimeout) {
        clearTimeout(verticalCenterTimeout);
        verticalCenterTimeout = null;
      }
    };

    window.addEventListener('wheel', cancelOnUserInput, { passive: true });
    window.addEventListener('touchstart', cancelOnUserInput, { passive: true });
    window.addEventListener('touchmove', cancelOnUserInput, { passive: true });
    window.addEventListener('keydown', (e) => {
      const k = e.key;
      if (k === 'ArrowUp' || k === 'ArrowDown' || k === 'PageUp' || k === 'PageDown' || k === 'Home' || k === 'End' || k === ' ') {
        cancelOnUserInput(e);
      }
    }, { passive: true });

    const snapState = window.snapState || (window.snapState = {
      isSnapping: false,
      activeSnapTrack: null,
      activeSnapTop: null
    });

    function updateActiveTrackFromWindowScroll() {
      if (!shelfTracks.length) return;
      const hero = document.querySelector('.hero');
      const scrollTop = window.scrollY || window.pageYOffset || 0;
      const doc = document.documentElement;
      const body = document.body;
      const maxScrollTop = Math.max(0, Math.max(
        doc.scrollHeight, body.scrollHeight,
        doc.offsetHeight, body.offsetHeight,
        doc.clientHeight
      ) - window.innerHeight);

      let closestTrack = null;
      let smallestDistance = Infinity;

      const MOBILE_ACTIVE_TRACK_HYSTERESIS_PX = 28; // px
      const SNAP_ACTIVE_TRACK_HYSTERESIS_PX = 90; // px

      const HERO_ACTIVE_HYSTERESIS_PX = 48;
      const HERO_TOP_SAFE_PX = 140;

      const heroTargetTop = hero
        ? Math.max(0, Math.min(computeVerticalCenterTargetTop(hero), maxScrollTop))
        : null;

      function targetTopForTrack(track) {
        if (!track) return null;
        if (hero && track === hero) return heroTargetTop;
        return Math.max(0, Math.min(computeVerticalCenterTargetTop(track), maxScrollTop));
      }

      if (snapState.isSnapping) {
        if (snapState.activeSnapTrack) {
          closestTrack = snapState.activeSnapTrack;
          const lockedTargetTop = targetTopForTrack(closestTrack);
          if (lockedTargetTop === null) return;
          smallestDistance = Math.abs(scrollTop - lockedTargetTop);
        } else {
          return;
        }
      }

      if (!closestTrack) {
        const candidates = hero ? [hero, ...shelfTracks] : shelfTracks;
        for (const track of candidates) {
          const targetTop = targetTopForTrack(track);
          if (targetTop === null) continue;
          const distance = Math.abs(scrollTop - targetTop);

          if (distance < smallestDistance) {
            smallestDistance = distance;
            closestTrack = track;
          }
        }
      }

      if (!closestTrack) return;

      if (hero && heroTargetTop !== null) {
        const heroDistance = Math.abs(scrollTop - heroTargetTop);
        if (heroDistance <= (smallestDistance - HERO_ACTIVE_HYSTERESIS_PX)) {
          closestTrack = hero;
          smallestDistance = heroDistance;
        } else if (scrollTop <= heroTargetTop + HERO_TOP_SAFE_PX) {
          if (heroDistance <= (smallestDistance + HERO_ACTIVE_HYSTERESIS_PX)) {
            closestTrack = hero;
            smallestDistance = heroDistance;
          }
        }
      }

      if (hero && heroTargetTop !== null) {
        const heroRect = hero.getBoundingClientRect();
        const heroInView = heroRect.bottom > 0 && heroRect.top < window.innerHeight;
        const visibleTop = Math.max(0, heroRect.top);
        const visibleBottom = Math.min(window.innerHeight, heroRect.bottom);
        const visibleHeight = Math.max(0, visibleBottom - visibleTop);
        const heroVisibleRatio = heroRect.height > 0 ? (visibleHeight / heroRect.height) : 0;
        const heroDominatesView = heroVisibleRatio >= 0.6;
        if (heroInView && heroRect.top <= HERO_TOP_SAFE_PX && heroDominatesView) {
          closestTrack = hero;
        }
      }

      // Mobile-only hysteresis: avoid rapid toggling near row boundaries.
      if (isMobileView() && lastActiveTrack && lastActiveTrack !== closestTrack) {
        const lastTargetTop = targetTopForTrack(lastActiveTrack);
        if (lastTargetTop === null) return;
        const lastDistance = Math.abs(scrollTop - lastTargetTop);
        const hysteresis = snapState.isSnapping
          ? SNAP_ACTIVE_TRACK_HYSTERESIS_PX
          : MOBILE_ACTIVE_TRACK_HYSTERESIS_PX;

        // Switch only if the new closest is closer by at least the threshold.
        if (!(smallestDistance <= (lastDistance - hysteresis))) {
          closestTrack = lastActiveTrack;
          smallestDistance = lastDistance;
        }
      }

      const previousActiveTrack = lastActiveTrack;

      if (previousActiveTrack && previousActiveTrack !== closestTrack) {
        previousActiveTrack.classList.remove('shelf-track--active');
        previousActiveTrack.classList.remove('hero--active');
      }
      if (closestTrack.classList.contains('shelf-track')) {
        closestTrack.classList.add('shelf-track--active');
        if (hero) hero.classList.remove('hero--active');
      } else if (closestTrack.classList.contains('hero')) {
        closestTrack.classList.add('hero--active');
      }
      lastActiveTrack = closestTrack;

      if (previousActiveTrack !== closestTrack) {
        if (isMobileView()) {
        } else {
          if (closestTrack.classList.contains('shelf-track')) {
            recenterTrackActivePoster(closestTrack);
            recenterAllOtherTracks(closestTrack);
          }
        }
      }

      if (previousActiveTrack !== closestTrack) {
        const playbackUpdater = window.updateHeroPlaybackState;
        if (typeof playbackUpdater === 'function') {
          playbackUpdater({ allowDelayedPause: true });
        }
      }
    }

    window.addEventListener('scroll', () => {
      lastWindowScrollEventAt = performance.now();
      if (windowScrollRaf !== null) return;
      windowScrollRaf = requestAnimationFrame(() => {
        windowScrollRaf = null;
        updateActiveTrackFromWindowScroll();
      });
    }, { passive: true });

    window.updateActiveTrackFromWindowScroll = updateActiveTrackFromWindowScroll;
    updateActiveTrackFromWindowScroll();

    document.querySelectorAll('.shelf-track').forEach(track => {
      const originalPosters = Array.from(track.children);
      if (originalPosters.length === 0) return;

      // --- 1. CLONE POSTERS for infinite effect ---
      const fragment = document.createDocumentFragment();
      originalPosters.forEach(poster => fragment.appendChild(poster.cloneNode(true)));

      for (let i = 0; i < CLONE_COUNT; i++) {
        track.prepend(fragment.cloneNode(true));
        track.append(fragment.cloneNode(true));
      }

      // --- 2. SET INITIAL SCROLL POSITION ---
      // We want to start at the first "real" card, not the clones.
      const initialPosterIndex = originalPosters.length * CLONE_COUNT;
      const initialPoster = track.children[initialPosterIndex];
      if (!initialPoster) return;

      // Calculate the position to perfectly center the first real poster on load
      const trackRect = track.getBoundingClientRect();
      const initialPosterRect = initialPoster.getBoundingClientRect();
      track.scrollLeft = initialPoster.offsetLeft - (trackRect.width / 2) + (initialPosterRect.width / 2);

      // --- 3. Continuous magnifier scaling + active card ---
      function updateScalesAndActive() {
        const trackRect = track.getBoundingClientRect();
        const trackCenterX = trackRect.left + trackRect.width / 2;

        const maxScale = 1.12; // largest at center
        const minScale = 0.78; // smallest far away

        let closestPoster = null;
        let smallestDistance = Infinity;
        const halfWidth = trackRect.width / 2 || 1; // avoid divide by zero
        const maxZ = 1000; // base for stacking order

        for (const poster of track.children) {
          const rect = poster.getBoundingClientRect();
          const posterCenterX = rect.left + rect.width / 2;

          const distance = Math.abs(trackCenterX - posterCenterX);

          const t = Math.min(distance / halfWidth, 1); // 0 at center, 1 at far edge

          const scale = maxScale - (maxScale - minScale) * t;
          poster.style.transform = 'scale(' + scale.toFixed(3) + ')';

          // Depth-based z-index: nearer to center = higher z-index
          const depth = 1 - t; // 1 at center, 0 at far edge
          const z = Math.round(depth * 100) + 1;
          poster.style.zIndex = String(z);

          if (distance < smallestDistance) {
            smallestDistance = distance;
            closestPoster = poster;
          }
        }

        if (closestPoster) {
          for (const poster of track.children) {
            if (poster === closestPoster) {
              poster.classList.add('is-active');
              // Ensure active card always sits on top of neighbors
              poster.style.zIndex = String(maxZ);
            } else {
              poster.classList.remove('is-active');
            }
          }
        }
      }

      let scrollEndTimeout = null;

      const handleScroll = () => {
        const isAnimating = !!track.__scrollAnimating;

        // Always keep the magnifier / active-card state in sync
        updateScalesAndActive();

        if (!isAnimating) {
          const previousActiveTrack = lastActiveTrack;

          // Toggle the active shelf-track for row-scoped neon
          if (previousActiveTrack && previousActiveTrack !== track) {
            previousActiveTrack.classList.remove('shelf-track--active');
            previousActiveTrack.classList.remove('hero--active');
          }
          track.classList.add('shelf-track--active');
          lastActiveTrack = track;

          if (previousActiveTrack !== track) {
            recenterAllOtherTracks(track);
          }

          // Same-row behavior: when the user scrolls away and then stops,
          // gently recenter the active card in this row.
          if (scrollEndTimeout) {
            clearTimeout(scrollEndTimeout);
          }
          scrollEndTimeout = setTimeout(() => {
            if (!track.__scrollAnimating) {
              recenterTrackActivePoster(track);
            }
          }, 120);
        }
      };

      track.addEventListener('scroll', handleScroll);

      // Ensure the first magnifier run happens after scrollLeft/layout settle
      requestAnimationFrame(updateScalesAndActive);

      // Recalculate magnifier whenever the viewport size changes
      window.addEventListener('resize', () => {
        requestAnimationFrame(updateScalesAndActive);
      });

      // Desktop-only grab-to-drag behavior
      if (window.matchMedia && window.matchMedia('(pointer: fine)').matches) {
        let isDragging = false;
        let startX;
        let startScrollLeft;

        track.addEventListener('mousedown', (event) => {
          if (event.button !== 0) return; // left button only
          cancelScrollAnimation(track);
          isDragging = true;
          track.classList.add('is-dragging');
          startX = event.pageX - track.offsetLeft;
          startScrollLeft = track.scrollLeft;
        });

        track.addEventListener('mousemove', (event) => {
          if (!isDragging) return;
          event.preventDefault();
          const x = event.pageX - track.offsetLeft;
          const walk = x - startX;
          track.scrollLeft = startScrollLeft - walk;
        });

        const stopDragging = () => {
          if (!isDragging) return;
          isDragging = false;
          track.classList.remove('is-dragging');
        };

        track.addEventListener('mouseleave', stopDragging);
        track.addEventListener('mouseup', stopDragging);
      }

      // Cancel any ongoing recenter animation when the user manually scrolls
      track.addEventListener('wheel', (event) => {
        if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
          cancelScrollAnimation(track);
        }
      }, { passive: true });

      track.addEventListener('touchstart', () => {
        cancelScrollAnimation(track);
      }, { passive: true });
    });

    requestAnimationFrame(() => {
      updateActiveTrackFromWindowScroll();
    });
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    var debugButton = document.getElementById('debugToggleButton');
    if (!debugButton) return;

    function syncDebugButtonState() {
      var isActive = document.body.classList.contains('debug-layout');
      debugButton.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    }

    syncDebugButtonState();

    debugButton.addEventListener('click', function () {
      document.body.classList.toggle('debug-layout');
      syncDebugButtonState();
    });
  });
</script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      
      const morphCards = Array.from(document.querySelectorAll('.poster[data-morph-id]'));

      // Note: shelves clone posters for infinite scrolling. We use event delegation
      // and per-card data-morph-id so both originals and clones open correctly.
      const previewOverlay = document.querySelector('.preview-overlay');
      const previewCloseButton = document.querySelector('.preview-close-btn');
      const previewTitleEl = document.querySelector('.preview-title');
      const previewRuntimeEl = document.querySelector('.preview-runtime');
      const previewTagsEl = document.querySelector('.preview-tags');
      const previewDescriptionEl = document.querySelector('.preview-description');

      if (
        !morphCards.length ||
        !previewOverlay ||
        !previewCloseButton ||
        !previewTitleEl ||
        !previewRuntimeEl ||
        !previewTagsEl ||
        !previewDescriptionEl
      ) {
        return;
      }

      const heroSection = document.querySelector('.hero');
      const heroVisual = document.querySelector('.hero-video');
      const HERO_PAUSE_DELAY = 1000;
      const HERO_VISIBLE_RATIO = 0.6;
      const HERO_AUDIO_FADE_MS = 1200;

      let heroAudioFadeInterval = null;
      let heroPausedTime = null;
      let heroTargetVolume = 100;
      let heroPauseTimeout = null;
      let heroIsVisible = false;
      let heroWasActive = false;
      let heroPausedByUs = false;
      let heroPauseScheduled = false;
      let heroPauseCandidate = null;

      function cancelHeroAudioFade() {
        if (heroAudioFadeInterval !== null) {
          clearInterval(heroAudioFadeInterval);
          heroAudioFadeInterval = null;
        }
      }

      function cancelHeroPause() {
        if (heroPauseTimeout !== null) {
          clearTimeout(heroPauseTimeout);
          heroPauseTimeout = null;
        }
        heroPauseScheduled = false;
        heroPauseCandidate = null;
      }

      function isPreviewOpen() {
        return previewOverlay.classList.contains('is-visible');
      }

      function captureHeroPausedTime() {
        try {
          if (typeof ytPlayer !== 'undefined' && ytPlayer && typeof ytPlayer.getCurrentTime === 'function') {
            const t = ytPlayer.getCurrentTime();
            if (typeof t === 'number' && isFinite(t)) {
              heroPausedTime = t;
            }
          }
        } catch (_) {}
      }

      function startHeroAudioFade(targetVolume, durationMs, onComplete) {
        cancelHeroAudioFade();
        if (!ytPlayer || typeof ytPlayer.setVolume !== 'function') return;

        let startVolume = 100;
        try {
          if (typeof ytPlayer.getVolume === 'function') {
            const current = ytPlayer.getVolume();
            if (typeof current === 'number' && isFinite(current)) startVolume = current;
          }
        } catch (_) {}

        const stepMs = 100;
        const steps = Math.max(1, Math.round(durationMs / stepMs));
        let step = 0;

        heroAudioFadeInterval = setInterval(() => {
          step += 1;
          const t = Math.min(step / steps, 1);
          const vol = Math.round(startVolume + (targetVolume - startVolume) * t);
          try {
            ytPlayer.setVolume(vol);
          } catch (_) {}
          if (t >= 1) {
            cancelHeroAudioFade();
            if (typeof onComplete === 'function') onComplete();
          }
        }, stepMs);
      }

      function pauseHeroVideo({ withDelay, force, expectedActiveShelf } = {}) {
        if (!withDelay) {
          cancelHeroPause();
        }

        const pauseAction = () => {
          try {
            if (typeof ytPlayer !== 'undefined' && ytPlayer && typeof ytPlayer.pauseVideo === 'function') {
              if (!force && isHeroActive()) return;
              if (!force && isPreviewOpen()) return;
              captureHeroPausedTime();
              if (typeof isMuted !== 'undefined' && !isMuted) {
                try {
                  if (typeof ytPlayer.getVolume === 'function') {
                    const current = ytPlayer.getVolume();
                    if (typeof current === 'number' && isFinite(current)) {
                      heroTargetVolume = current;
                    }
                  }
                } catch (_) {}
                startHeroAudioFade(0, HERO_AUDIO_FADE_MS, () => {
                  try { ytPlayer.pauseVideo(); } catch (_) {}
                  heroPausedByUs = true;
                });
              } else {
                ytPlayer.pauseVideo();
                heroPausedByUs = true;
              }
            }
          } catch (_) {}
        };

        if (withDelay) {
          if (heroPauseScheduled) return;
          heroPauseScheduled = true;
          const scheduledShelf = expectedActiveShelf || document.querySelector('.shelf-track--active');
          heroPauseCandidate = scheduledShelf || null;
          heroPauseTimeout = setTimeout(() => {
            heroPauseTimeout = null;
            heroPauseScheduled = false;
            const currentActiveShelf = document.querySelector('.shelf-track--active');
            const pauseCandidate = heroPauseCandidate;
            heroPauseCandidate = null;
            if (!currentActiveShelf || !pauseCandidate || currentActiveShelf !== pauseCandidate) {
              return;
            }
            if (currentActiveShelf.classList.contains('hero')) {
              return;
            }
            if (isHeroActive()) {
              return;
            }
            pauseAction();
          }, HERO_PAUSE_DELAY);
        } else {
          pauseAction();
        }
      }

      function resumeHeroPlayback() {
        if (typeof ytPlayer === 'undefined' || !ytPlayer) return;
        if (isPreviewOpen()) return;
        if (!isHeroActive()) return;

        let playerState = null;
        try {
          if (typeof ytPlayer.getPlayerState === 'function') {
            playerState = ytPlayer.getPlayerState();
          }
        } catch (_) {}

        if (playerState === 1 || playerState === 3) {
          return;
        }

        try {
          let currentHeroTime = null;
          try {
            if (typeof ytPlayer.getCurrentTime === 'function') {
              const ct = ytPlayer.getCurrentTime();
              if (typeof ct === 'number' && isFinite(ct)) currentHeroTime = ct;
            }
          } catch (_) {}

          const hasPausedTime =
            (typeof heroPausedTime === 'number' && isFinite(heroPausedTime) && heroPausedTime > 0.25);
          const hasCurrentTime =
            (typeof currentHeroTime === 'number' && isFinite(currentHeroTime));

          const needsSeekBack =
            heroPausedByUs &&
            hasPausedTime &&
            hasCurrentTime &&
            (currentHeroTime < 0.5 || Math.abs(currentHeroTime - heroPausedTime) > 2.0);

          if (heroPausedByUs && (playerState === 2 || playerState === 5) && needsSeekBack && typeof ytPlayer.seekTo === 'function') {
            try { ytPlayer.seekTo(heroPausedTime, true); } catch (_) {}
          }

          if ((playerState === 2 || playerState === 5) && typeof ytPlayer.playVideo === 'function') {
            ytPlayer.playVideo();
          }

          if (typeof isMuted !== 'undefined' && isMuted) {
            if (typeof ytPlayer.mute === 'function') ytPlayer.mute();
          } else {
            try {
              if (typeof ytPlayer.unMute === 'function') ytPlayer.unMute();
            } catch (_) {}
            const targetVolume = typeof heroTargetVolume === 'number' && isFinite(heroTargetVolume)
              ? heroTargetVolume
              : 100;
            startHeroAudioFade(targetVolume, 1400);
          }
        } catch (_) {}
        heroPausedByUs = false;
      }

      function isHeroActive() {
        return heroSection && heroSection.classList.contains('hero--active');
      }

      function updateHeroPlaybackState({ allowDelayedPause } = {}) {
        if (!heroSection) return;
        const wasHeroActive = heroWasActive;
        const heroActive = isHeroActive();
        const isMobile = typeof window.isMobileView === 'function' && window.isMobileView();
        const heroPlaybackRequested = window.heroPlaybackRequested === true;
        const activeShelf = document.querySelector('.shelf-track--active');
        const otherShelfActive = !!(activeShelf && !activeShelf.classList.contains('hero'));
        const heroActiveForPlayback = heroActive || (isMobile && heroIsVisible);
        if (isPreviewOpen()) {
          pauseHeroVideo({ force: true });
          heroWasActive = heroActiveForPlayback;
          return;
        }
        if (otherShelfActive && !heroActive) {
          heroWasActive = false;
          pauseHeroVideo({ withDelay: true, expectedActiveShelf: activeShelf });
          return;
        }
        if (heroActiveForPlayback && isPlayNowHighlighted()) {
          if (!wasHeroActive) {
            cancelHeroPause();
          }
          resumeHeroPlayback();
          heroWasActive = true;
          return;
        }
        heroWasActive = false;
        if (allowDelayedPause && otherShelfActive) {
          pauseHeroVideo({ withDelay: true, expectedActiveShelf: activeShelf });
          return;
        }
        pauseHeroVideo({ force: true });
      }

      window.updateHeroPlaybackState = updateHeroPlaybackState;

      if (heroSection && 'IntersectionObserver' in window) {
        const heroObserver = new IntersectionObserver((entries) => {
          const entry = entries[0];
          heroIsVisible = !!(entry && entry.isIntersecting);
          if (typeof window.updateActiveTrackFromWindowScroll === 'function') {
            window.updateActiveTrackFromWindowScroll();
          }
          updateHeroPlaybackState({ allowDelayedPause: true });
        }, {
          threshold: [0, HERO_VISIBLE_RATIO, 1]
        });

        heroObserver.observe(heroSection);
      } else if (heroSection) {
        const rect = heroSection.getBoundingClientRect();
        heroIsVisible = rect.top < window.innerHeight && rect.bottom > 0;
      }

      window.addEventListener('scroll', () => {
        if (!heroSection) return;
        if (typeof window.updateActiveTrackFromWindowScroll === 'function') {
          window.updateActiveTrackFromWindowScroll();
        }
        updateHeroPlaybackState({ allowDelayedPause: true });
      }, { passive: true });

      const MORPH_DURATION = 520;
      const PREVIEW_EASING = 'cubic-bezier(0.25, 0.1, 0.25, 1)';
      const FILL_FADE_DURATION = 220;
      let lastOpenedCard = null;

      let scrollLockState = null;

      function lockScroll() {
        if (scrollLockState) return;
        const docEl = document.documentElement;
        const body = document.body;

        scrollLockState = {
          htmlOverflow: docEl.style.overflow,
          bodyOverflow: body.style.overflow,
          bodyPaddingRight: body.style.paddingRight
        };

        const supportsStableScrollbarGutter =
          window.CSS && typeof CSS.supports === 'function' && CSS.supports('scrollbar-gutter: stable');

        if (!supportsStableScrollbarGutter) {
          const scrollbarWidth = window.innerWidth - docEl.clientWidth;
          if (scrollbarWidth > 0) {
            const computedPaddingRight = window.getComputedStyle(body).paddingRight;
            const currentPadding = parseFloat(computedPaddingRight) || 0;
            body.style.paddingRight = `${currentPadding + scrollbarWidth}px`;
          }
        }

        docEl.style.overflow = 'hidden';
        body.style.overflow = 'hidden';
      }

      function unlockScroll() {
        if (!scrollLockState) return;
        const docEl = document.documentElement;
        const body = document.body;

        docEl.style.overflow = scrollLockState.htmlOverflow;
        body.style.overflow = scrollLockState.bodyOverflow;
        body.style.paddingRight = scrollLockState.bodyPaddingRight;

        scrollLockState = null;
      }
      let activeMorphTile = null;

      let currentMorphDuration = MORPH_DURATION;
      let currentMorphEasing = PREVIEW_EASING;

      const OPEN_MORPH_PROFILES = [
        { id: 'morph-01', name: 'Straight Zoom', kf: 'straight', duration: 520, easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)' },
        { id: 'morph-02', name: 'Arc Sweep', kf: 'arcSweep', duration: 520, easing: 'cubic-bezier(0.18, 0.80, 0.20, 1)', arcX: 46, arcY: -34 },
        { id: 'morph-03', name: 'Overshoot Snap', kf: 'overshootSnap', duration: 480, easing: 'cubic-bezier(0.16, 1, 0.3, 1)', overshoot: 18 },
        { id: 'morph-04', name: 'Spring Elastic', kf: 'springElastic', duration: 720, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', bounce: 3 },
        { id: 'morph-05', name: 'Hinge Flip', kf: 'hingeFlip', duration: 520, easing: 'cubic-bezier(0.20, 0.90, 0.20, 1)', tilt: 10 },
        { id: 'morph-06', name: 'Yaw Rotate', kf: 'yawRotate', duration: 520, easing: 'cubic-bezier(0.20, 0.90, 0.20, 1)', yaw: 14 },
        { id: 'morph-07', name: 'Pop In Place', kf: 'popInPlace', duration: 520, easing: 'cubic-bezier(0.12, 0.90, 0.10, 1)' },
        { id: 'morph-08', name: 'Slide + Fade Cross', kf: 'slideFadeCross', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', slideX: 80 },
        { id: 'morph-09', name: 'Vertical Drop', kf: 'verticalDrop', duration: 520, easing: 'cubic-bezier(0.20, 0.90, 0.20, 1)', dropY: 64 },
        { id: 'morph-10', name: 'Diagonal Slash', kf: 'diagonalSlash', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', slashX: 72, slashY: -72 },

        { id: 'morph-11', name: 'Squash & Stretch', kf: 'squashStretch', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-12', name: 'Blur Burst', kf: 'blurBurst', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', blurPx: 10 },
        { id: 'morph-13', name: 'Shutter Wipe', kf: 'shutterWipe', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-14', name: 'Portal Zoom Through', kf: 'portalZoom', duration: 620, easing: 'cubic-bezier(0.16, 1, 0.3, 1)', portal: 1.22 },
        { id: 'morph-15', name: 'Card Stack Lift', kf: 'stackLift', duration: 560, easing: 'cubic-bezier(0.18, 0.80, 0.20, 1)', lift: 18 },
        { id: 'morph-16', name: 'Parallax Drift', kf: 'parallaxDrift', duration: 620, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', driftX: 18, driftY: -12 },
        { id: 'morph-17', name: 'Skew Shear', kf: 'skewShear', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)', skewDeg: 10 },
        { id: 'morph-18', name: 'Glitch Jitter', kf: 'glitchJitter', duration: 520, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-19', name: 'Ripple Expand', kf: 'rippleExpand', duration: 560, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' },
        { id: 'morph-20', name: 'Cinematic Ease', kf: 'cinematicEase', duration: 720, easing: 'cubic-bezier(0.22, 0.61, 0.36, 1)' }
      ];

      function getOpenMorphProfileForCard(card) {
        // Force ALL cards to use the same open morph as B6 (morph-16: Parallax Drift).
        const forced = OPEN_MORPH_PROFILES.find(p => p.id === 'morph-01');
        return forced || OPEN_MORPH_PROFILES[0];
      }

      function buildBoostedShadow(baseShadow, boost) {
        const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim() || '#e31b23';
        const glowA = 10 + Math.round(22 * boost);
        const glowB = 26 + Math.round(54 * boost);
        const alphaA = (0.18 + 0.45 * boost).toFixed(2);
        const alphaB = (0.10 + 0.28 * boost).toFixed(2);
        const extra = `0 0 ${glowA}px rgba(227,27,35,${alphaA}), 0 0 ${glowB}px rgba(227,27,35,${alphaB})`;
        if (!baseShadow || baseShadow === 'none') return extra;
        return `${baseShadow}, ${extra}`;
      }

      function animateOpenTile(tile, startRect, endRect, cardRadius, targetRadius, previewShadow, previewBorderColor, profile) {
        const fill = tile.querySelector('.preview-morph-fill');

        const startTileShadow = getComputedStyle(tile).boxShadow;
        const startTileBorderColor = getComputedStyle(tile).borderColor;

        const startX = startRect.left;
        const startY = startRect.top;
        const endX = endRect.left;
        const endY = endRect.top;

        const startW = startRect.width;
        const startH = startRect.height;
        const endW = endRect.width;
        const endH = endRect.height;

        const dX = endX - startX;
        const dY = endY - startY;

        const baseStart = {
          transform: `translate(${startX}px, ${startY}px)`,
          width: `${startW}px`,
          height: `${startH}px`,
          borderRadius: cardRadius,
          boxShadow: startTileShadow,
          borderColor: startTileBorderColor,
          opacity: 1,
          filter: 'none'
        };

        const baseEnd = {
          transform: `translate(${endX}px, ${endY}px)`,
          width: `${endW}px`,
          height: `${endH}px`,
          borderRadius: targetRadius,
          boxShadow: previewShadow,
          borderColor: previewBorderColor,
          opacity: 1,
          filter: 'none'
        };

        // Ensure a clean baseline (no residual transforms / filters).
        tile.style.transition = 'none';
        tile.style.transformOrigin = 'top left';
        tile.style.filter = 'none';
        tile.style.opacity = '1';
        tile.style.clipPath = '';
        tile.style.borderRadius = cardRadius;
        tile.style.boxShadow = startTileShadow;
        tile.style.borderColor = startTileBorderColor;

        if (fill) {
          fill.style.filter = 'none';
          fill.style.opacity = '1';
          fill.style.clipPath = '';
          fill.style.transform = 'none';
          fill.style.backgroundPosition = 'center';
        }

        const kf = (profile && profile.kf) ? profile.kf : 'straight';
        const dur = (profile && profile.duration) ? profile.duration : MORPH_DURATION;
        const ease = (profile && profile.easing) ? profile.easing : PREVIEW_EASING;

        const kfs = [];
        let options = { duration: dur, easing: ease, fill: 'forwards' };

        // Some concepts benefit from per-segment easing (keyframe easings).
        const midShadowStrong = buildBoostedShadow(previewShadow, 0.70);
        const midShadowSoft = buildBoostedShadow(previewShadow, 0.35);

        const add = (obj) => kfs.push(obj);

        if (kf === 'straight') {
          add({ offset: 0, ...baseStart });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'arcSweep') {
          const ax = (profile && profile.arcX != null) ? profile.arcX : 40;
          const ay = (profile && profile.arcY != null) ? profile.arcY : -28;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.55,
            transform: `translate(${startX + dX * 0.55 + ax}px, ${startY + dY * 0.55 + ay}px) rotate(0deg)`,
            width: `${startW + (endW - startW) * 0.55}px`,
            height: `${startH + (endH - startH) * 0.55}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.70)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'overshootSnap') {
          const os = (profile && profile.overshoot != null) ? profile.overshoot : 16;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.78,
            transform: `translate(${endX + os}px, ${endY - os * 0.45}px)`,
            width: `${endW * 1.02}px`,
            height: `${endH * 1.02}px`,
            borderRadius: `calc(${targetRadius} * 0.92)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
          });
          add({
            offset: 1,
            ...baseEnd,
            easing: 'cubic-bezier(0.20, 0.80, 0.20, 1)'
          });
        }

        else if (kf === 'springElastic') {
          const b = (profile && profile.bounce != null) ? profile.bounce : 3;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.58,
            transform: `translate(${endX + 18}px, ${endY - 10}px)`,
            width: `${endW * 1.04}px`,
            height: `${endH * 1.04}px`,
            borderRadius: `calc(${targetRadius} * 0.88)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
          });
          add({
            offset: 0.74,
            transform: `translate(${endX - 10}px, ${endY + 6}px)`,
            width: `${endW * 0.99}px`,
            height: `${endH * 0.99}px`,
            borderRadius: `calc(${targetRadius} * 1.02)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
          });
          if (b >= 3) {
            add({
              offset: 0.86,
              transform: `translate(${endX + 4}px, ${endY - 3}px)`,
              width: `${endW * 1.01}px`,
              height: `${endH * 1.01}px`,
              borderRadius: targetRadius,
              boxShadow: previewShadow,
              borderColor: previewBorderColor,
              easing: 'cubic-bezier(0.20, 0.80, 0.20, 1)'
            });
          }
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'hingeFlip') {
          const tilt = (profile && profile.tilt != null) ? profile.tilt : 10;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.45,
            transform: `translate(${startX + dX * 0.45}px, ${startY + dY * 0.45}px) perspective(900px) rotateX(${tilt}deg) rotateZ(-4deg)`,
            width: `${startW + (endW - startW) * 0.45}px`,
            height: `${startH + (endH - startH) * 0.45}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.55)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) perspective(900px) rotateX(-4deg) rotateZ(2deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'yawRotate') {
          const yaw = (profile && profile.yaw != null) ? profile.yaw : 14;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52}px, ${startY + dY * 0.52}px) perspective(900px) rotateY(${yaw}deg)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.60)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) perspective(900px) rotateY(-6deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'popInPlace') {
          // Lingers near start, then "pops" and travels late.
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.40,
            transform: `translate(${startX + dX * 0.12}px, ${startY + dY * 0.12}px) scale(1.08)`,
            width: `${startW + (endW - startW) * 0.18}px`,
            height: `${startH + (endH - startH) * 0.18}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.30)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            opacity: 1
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) scale(1.02)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'slideFadeCross') {
          const slideX = (profile && profile.slideX != null) ? profile.slideX : 80;

          add({ offset: 0, ...baseStart, opacity: 1 });
          add({
            offset: 0.45,
            transform: `translate(${startX + dX * 0.45 + slideX}px, ${startY + dY * 0.45}px)`,
            width: `${startW + (endW - startW) * 0.45}px`,
            height: `${startH + (endH - startH) * 0.45}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.50)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            opacity: 0.45
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor,
            opacity: 1
          });
          add({ offset: 1, ...baseEnd, opacity: 1 });
        }

        else if (kf === 'verticalDrop') {
          const drop = (profile && profile.dropY != null) ? profile.dropY : 64;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.60,
            transform: `translate(${startX + dX * 0.60}px, ${startY + dY * 0.60 + drop}px)`,
            width: `${startW + (endW - startW) * 0.60}px`,
            height: `${startH + (endH - startH) * 0.60}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.68)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.86,
            transform: `translate(${endX}px, ${endY}px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'diagonalSlash') {
          const sx = (profile && profile.slashX != null) ? profile.slashX : 72;
          const sy = (profile && profile.slashY != null) ? profile.slashY : -72;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52 + sx}px, ${startY + dY * 0.52 + sy}px) rotate(-6deg)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.62)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.80,
            transform: `translate(${endX}px, ${endY}px) rotate(2deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'squashStretch') {
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.28,
            transform: `translate(${startX + dX * 0.28}px, ${startY + dY * 0.28}px) scaleX(0.92) scaleY(1.08)`,
            width: `${startW + (endW - startW) * 0.28}px`,
            height: `${startH + (endH - startH) * 0.28}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.42)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.58,
            transform: `translate(${startX + dX * 0.58}px, ${startY + dY * 0.58}px) scaleX(1.08) scaleY(0.96)`,
            width: `${startW + (endW - startW) * 0.58}px`,
            height: `${startH + (endH - startH) * 0.58}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.70)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'blurBurst') {
          const blurPx = (profile && profile.blurPx != null) ? profile.blurPx : 10;

          add({ offset: 0, ...baseStart, filter: 'blur(0px)' });
          add({
            offset: 0.48,
            transform: `translate(${startX + dX * 0.48}px, ${startY + dY * 0.48}px)`,
            width: `${startW + (endW - startW) * 0.48}px`,
            height: `${startH + (endH - startH) * 0.48}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.60)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            filter: `blur(${blurPx}px)`
          });
          add({ offset: 0.72, filter: 'blur(0px)' });
          add({ offset: 1, ...baseEnd, filter: 'blur(0px)' });
        }

        else if (kf === 'shutterWipe') {
          // Tile moves normally; the fill reveals like a shutter wipe.
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.55,
            transform: `translate(${startX + dX * 0.55}px, ${startY + dY * 0.55}px)`,
            width: `${startW + (endW - startW) * 0.55}px`,
            height: `${startH + (endH - startH) * 0.55}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.70)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });

          if (fill) {
            try {
              fill.animate([
                { offset: 0, clipPath: 'inset(0 0 0 0)' },
                { offset: 0.18, clipPath: 'inset(0 0 0 0)' },
                { offset: 0.55, clipPath: 'inset(0 0 0 100%)' },
                { offset: 0.74, clipPath: 'inset(0 0 0 0)' },
                { offset: 1, clipPath: 'inset(0 0 0 0)' }
              ], { duration: dur, easing: 'linear', fill: 'forwards' });
            } catch (e) { /* no-op */ }
          }
        }

        else if (kf === 'portalZoom') {
          const portal = (profile && profile.portal != null) ? profile.portal : 1.22;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.72,
            transform: `translate(${endX}px, ${endY}px) scale(${portal})`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.88,
            transform: `translate(${endX}px, ${endY}px) scale(0.98)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'stackLift') {
          const lift = (profile && profile.lift != null) ? profile.lift : 18;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.45,
            transform: `translate(${startX + dX * 0.45}px, ${startY + dY * 0.45 - lift}px) perspective(900px) translateZ(24px)`,
            width: `${startW + (endW - startW) * 0.45}px`,
            height: `${startH + (endH - startH) * 0.45}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.55)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.78,
            transform: `translate(${endX}px, ${endY}px) perspective(900px) translateZ(0px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'parallaxDrift') {
          const driftX = (profile && profile.driftX != null) ? profile.driftX : 18;
          const driftY = (profile && profile.driftY != null) ? profile.driftY : -12;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.62,
            transform: `translate(${startX + dX * 0.62}px, ${startY + dY * 0.62}px)`,
            width: `${startW + (endW - startW) * 0.62}px`,
            height: `${startH + (endH - startH) * 0.62}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.74)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });

          if (fill) {
            try {
              fill.animate([
                { offset: 0, transform: 'translate(0px, 0px) scale(1.00)', backgroundPosition: 'center' },
                { offset: 0.55, transform: `translate(${driftX}px, ${driftY}px) scale(1.06)`, backgroundPosition: '60% 40%' },
                { offset: 1, transform: 'translate(0px, 0px) scale(1.00)', backgroundPosition: 'center' }
              ], { duration: dur, easing: ease, fill: 'forwards' });
            } catch (e) { /* no-op */ }
          }
        }

        else if (kf === 'skewShear') {
          const skewDeg = (profile && profile.skewDeg != null) ? profile.skewDeg : 10;

          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52}px, ${startY + dY * 0.52}px) skewX(${skewDeg}deg)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.64)`,
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor
          });
          add({
            offset: 0.80,
            transform: `translate(${endX}px, ${endY}px) skewX(-4deg)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: targetRadius,
            boxShadow: previewShadow,
            borderColor: previewBorderColor
          });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'glitchJitter') {
          // Brief jitter micro-movements mid-flight.
          add({ offset: 0, ...baseStart });
          add({ offset: 0.40, transform: `translate(${startX + dX * 0.40}px, ${startY + dY * 0.40}px)`, width: `${startW + (endW - startW) * 0.40}px`, height: `${startH + (endH - startH) * 0.40}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.54)`, boxShadow: midShadowSoft, borderColor: previewBorderColor });
          add({ offset: 0.52, transform: `translate(${startX + dX * 0.52 + 6}px, ${startY + dY * 0.52 - 4}px)`, width: `${startW + (endW - startW) * 0.52}px`, height: `${startH + (endH - startH) * 0.52}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.64)`, boxShadow: midShadowSoft, borderColor: previewBorderColor });
          add({ offset: 0.56, transform: `translate(${startX + dX * 0.56 - 5}px, ${startY + dY * 0.56 + 3}px)`, width: `${startW + (endW - startW) * 0.56}px`, height: `${startH + (endH - startH) * 0.56}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.68)`, boxShadow: midShadowSoft, borderColor: previewBorderColor });
          add({ offset: 0.60, transform: `translate(${startX + dX * 0.60 + 4}px, ${startY + dY * 0.60 + 1}px)`, width: `${startW + (endW - startW) * 0.60}px`, height: `${startH + (endH - startH) * 0.60}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.72)`, boxShadow: midShadowStrong, borderColor: previewBorderColor });
          add({ offset: 0.68, transform: `translate(${startX + dX * 0.68}px, ${startY + dY * 0.68}px)`, width: `${startW + (endW - startW) * 0.68}px`, height: `${startH + (endH - startH) * 0.68}px`, borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.78)`, boxShadow: previewShadow, borderColor: previewBorderColor });
          add({ offset: 1, ...baseEnd });
        }

        else if (kf === 'rippleExpand') {
          add({ offset: 0, ...baseStart });
          add({
            offset: 0.52,
            transform: `translate(${startX + dX * 0.52}px, ${startY + dY * 0.52}px) scale(1.08)`,
            width: `${startW + (endW - startW) * 0.52}px`,
            height: `${startH + (endH - startH) * 0.52}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.66)`,
            boxShadow: midShadowStrong,
            borderColor: previewBorderColor,
            opacity: 0.85
          });
          add({
            offset: 0.72,
            transform: `translate(${startX + dX * 0.72}px, ${startY + dY * 0.72}px) scale(0.98)`,
            width: `${startW + (endW - startW) * 0.72}px`,
            height: `${startH + (endH - startH) * 0.72}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.82)`,
            boxShadow: previewShadow,
            borderColor: previewBorderColor,
            opacity: 1
          });
          add({ offset: 1, ...baseEnd, opacity: 1 });
        }

        else if (kf === 'cinematicEase') {
          // Slow start, fast mid, slow end + subtle radius timing offset.
          options = { duration: dur, easing: 'linear', fill: 'forwards' };

          add({ offset: 0, ...baseStart, easing: 'cubic-bezier(0.40, 0.00, 0.60, 1)' });
          add({
            offset: 0.22,
            transform: `translate(${startX + dX * 0.18}px, ${startY + dY * 0.18}px)`,
            width: `${startW + (endW - startW) * 0.18}px`,
            height: `${startH + (endH - startH) * 0.18}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.22)`,
            boxShadow: 'none',
            borderColor: 'rgba(255,255,255,0.10)',
            easing: 'cubic-bezier(0.40, 0.00, 0.60, 1)'
          });
          add({
            offset: 0.62,
            transform: `translate(${startX + dX * 0.74}px, ${startY + dY * 0.74}px)`,
            width: `${startW + (endW - startW) * 0.74}px`,
            height: `${startH + (endH - startH) * 0.74}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.55)`, /* radius lags */
            boxShadow: midShadowSoft,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.16, 1, 0.3, 1)'
          });
          add({
            offset: 0.86,
            transform: `translate(${endX}px, ${endY}px)`,
            width: `${endW}px`,
            height: `${endH}px`,
            borderRadius: `calc(${cardRadius} + (${targetRadius} - ${cardRadius}) * 0.86)`,
            boxShadow: previewShadow,
            borderColor: previewBorderColor,
            easing: 'cubic-bezier(0.40, 0.00, 0.60, 1)'
          });
          add({ offset: 1, ...baseEnd });
        }

        // Safety fallback
        if (!kfs.length) {
          kfs.push({ offset: 0, ...baseStart });
          kfs.push({ offset: 1, ...baseEnd });
        }

        const anim = tile.animate(kfs, options);

        // Hard constraint: end clean (no rotation, skew, blur, opacity issues).
        anim.onfinish = () => {
          tile.style.transform = baseEnd.transform;
          tile.style.width = baseEnd.width;
          tile.style.height = baseEnd.height;
          tile.style.borderRadius = baseEnd.borderRadius;
          tile.style.boxShadow = baseEnd.boxShadow;
          tile.style.borderColor = baseEnd.borderColor;
          tile.style.opacity = '1';
          tile.style.filter = 'none';
          tile.style.clipPath = '';

          if (fill) {
            fill.style.filter = 'none';
            fill.style.clipPath = '';
            fill.style.transform = 'none';
            fill.style.backgroundPosition = 'center';
          }
        };

        return anim;
      }

      function measurePreviewRect() {
        const previewCard = previewOverlay.querySelector('.preview-card');
        if (!previewCard) return null;

        const wasVisible = previewOverlay.classList.contains('is-visible');
        const wasActive = previewCard.classList.contains('is-active');
        const previousOverlayTransition = previewOverlay.style.transition;
        const previousCardTransition = previewCard.style.transition;
        const previousOverlayOpacity = previewOverlay.style.opacity;
        const previousOverlayVisibility = previewOverlay.style.visibility;
        const previousOverlayPointerEvents = previewOverlay.style.pointerEvents;
        const previousTransform = previewCard.style.transform;
        const previousOpacity = previewCard.style.opacity;

        previewOverlay.style.transition = 'none';
        previewCard.style.transition = 'none';

        previewOverlay.classList.add('is-visible');
        previewOverlay.setAttribute('aria-hidden', 'false');
        previewOverlay.style.opacity = '0';
        previewOverlay.style.visibility = 'hidden';
        previewOverlay.style.pointerEvents = 'none';

        previewCard.classList.add('is-active');
        previewCard.style.transform = '';
        previewCard.style.opacity = '';

        const rect = previewCard.getBoundingClientRect();

        if (!wasVisible) {
        }

        if (!wasActive) {
          previewCard.classList.remove('is-active');
        }

        previewOverlay.style.transition = previousOverlayTransition;
        previewCard.style.transition = previousCardTransition;
        previewOverlay.style.opacity = previousOverlayOpacity;
        previewOverlay.style.visibility = previousOverlayVisibility;
        previewOverlay.style.pointerEvents = previousOverlayPointerEvents;
        previewCard.style.transform = previousTransform;
        previewCard.style.opacity = previousOpacity;

        return rect;
      }

      function createGlowTileFromCard(card, startRect) {
        const tile = document.createElement('div');
        tile.className = 'preview-morph-tile';

        const fill = document.createElement('div');
        fill.className = 'preview-morph-fill';

        tile.classList.remove('is-fade-out');
        fill.classList.remove('is-fade-out');
        tile.style.opacity = '';
        fill.style.opacity = '1';

        const posterImg = card.querySelector('img');
        if (posterImg && posterImg.src) {
          fill.style.backgroundImage = `url(${posterImg.src})`;
        }

        tile.appendChild(fill);
        tile.style.width = `${startRect.width}px`;
        tile.style.height = `${startRect.height}px`;
        tile.style.transformOrigin = 'top left';
        tile.style.transform = `translate(${startRect.left}px, ${startRect.top}px) scale(1, 1)`;
        document.body.appendChild(tile);

        return { tile, fill };
      }

      function moveTile(tile, startRect, targetRect, targetRadius) {
        tile.style.borderRadius = targetRadius;
        tile.style.width = `${targetRect.width}px`;
        tile.style.height = `${targetRect.height}px`;
        tile.style.transform = `translate(${targetRect.left}px, ${targetRect.top}px)`;
      }

      function openPreviewFromCard(card, triggerElement = card) {
        // ZAQ TASK 1.8: Pause hero video when preview begins opening.
        pauseHeroVideo({ force: true });
        const title = 'Preview Placeholder Title';
        const runtime = '1h 52m';
        const tags = 'Thriller â€¢ Sciâ€‘Fi â€¢ Action';
        const description = 'This is a static placeholder description used for layout validation only. It is intentionally long so the text wraps across multiple lines and reveals spacing, rhythm, and hierarchy inside the Preview Modal. Replace this copy with real content in a later task once the layout has been visually approved.';
previewTitleEl.textContent = title;
        previewRuntimeEl.textContent = runtime;
        previewTagsEl.textContent = tags;
        previewDescriptionEl.textContent = description;

        lastOpenedCard = triggerElement;
        lockScroll();
        previewOverlay.setAttribute('aria-hidden', 'false');
        const profile = getOpenMorphProfileForCard(card);
        currentMorphDuration = profile.duration;
        currentMorphEasing = profile.easing;
        // Sync overlay/card CSS variable timings to this open.
        previewOverlay.style.setProperty('--preview-morph-duration', `${profile.duration}ms`);
        previewOverlay.style.setProperty('--preview-morph-ease', profile.easing);
        const previewCard = previewOverlay.querySelector('.preview-card');
        if (previewCard) {
          previewCard.style.setProperty('--preview-morph-duration', `${profile.duration}ms`);
          previewCard.style.setProperty('--preview-morph-ease', profile.easing);
        }
        runOpenMorph(card, profile);
      }

      const heroDetailsButton = document.querySelector('.hero-details-button');
      const heroPreviewSource = heroVisual || heroSection;

      if (heroDetailsButton && heroPreviewSource) {
        heroDetailsButton.addEventListener('click', (event) => {
          if (previewOverlay.classList.contains('is-visible')) return;
          event.preventDefault();
          event.stopPropagation();
          openPreviewFromCard(heroPreviewSource, heroDetailsButton);
        });
      }

      function runOpenMorph(card, profile) {
        return new Promise((resolve) => {
          const startRect = card.getBoundingClientRect();
          const previewCard = previewOverlay.querySelector('.preview-card');
          if (previewCard) {
            previewCard.style.opacity = '0';
            previewCard.style.transition = '';
            previewCard.classList.remove('is-hidden');
          }
          const endRect = measurePreviewRect();

          if (!previewCard || !endRect) {
            previewOverlay.classList.add('is-visible');
            previewCard.classList.add('is-active');
            resolve();
            return;
          }

          previewOverlay.style.opacity = '';
          previewOverlay.style.pointerEvents = '';
          previewOverlay.classList.add('is-visible');
          previewOverlay.setAttribute('aria-hidden', 'false');
          previewCard.classList.add('is-active');
          previewCard.style.opacity = '0';
          previewCard.style.transition = '';
          previewCard.style.transform = '';

          const previewShadow = getComputedStyle(previewCard).boxShadow;
          const previewBorderColor = getComputedStyle(previewCard).borderColor;

          const { tile, fill } = createGlowTileFromCard(card, startRect);

          const originalPreviewParent = previewCard.parentElement;
          const originalPreviewNextSibling = previewCard.nextSibling;

          tile.appendChild(previewCard);

          previewCard.style.position = 'absolute';
          previewCard.style.inset = '0';
          previewCard.style.width = '100%';
          previewCard.style.height = '100%';
          previewCard.style.margin = '0';
          previewCard.style.border = '0';
          previewCard.style.boxShadow = 'none';
          previewCard.style.borderRadius = 'inherit';
          previewCard.style.overflow = 'hidden';

          activeMorphTile = tile;
          const cardRadius = getComputedStyle(card).borderRadius;
          tile.style.borderRadius = cardRadius;
          const targetRadius = getComputedStyle(previewCard).borderRadius;

          fill.style.transition = '';
          fill.style.opacity = '1';

          let hasCrossfaded = false;

          const finishCrossfade = () => {
            if (!hasCrossfaded) return;

            if (originalPreviewParent) {
              if (originalPreviewNextSibling && originalPreviewNextSibling.parentNode === originalPreviewParent) {
                originalPreviewParent.insertBefore(previewCard, originalPreviewNextSibling);
              } else {
                originalPreviewParent.appendChild(previewCard);
              }
            }

            previewCard.style.position = '';
            previewCard.style.inset = '';
            previewCard.style.width = '';
            previewCard.style.height = '';
            previewCard.style.margin = '';
            previewCard.style.border = '';
            previewCard.style.boxShadow = '';
            previewCard.style.borderRadius = '';
            previewCard.style.overflow = '';

            tile.remove();
            if (activeMorphTile === tile) {
              activeMorphTile = null;
            }
            previewCard.style.transition = '';
            previewCard.style.opacity = '';
            resolve();
          };

          const handleCardFadeInEnd = (event) => {
            if (event.propertyName !== 'opacity') return;
            previewCard.removeEventListener('transitionend', handleCardFadeInEnd);
            finishCrossfade();
          };

          const startCrossfade = () => {
            if (hasCrossfaded) return;
            hasCrossfaded = true;
            previewCard.addEventListener('transitionend', handleCardFadeInEnd);
            previewCard.style.transition = `opacity ${FILL_FADE_DURATION}ms ${currentMorphEasing}`;
            fill.style.transition = `opacity ${FILL_FADE_DURATION}ms ${currentMorphEasing}`;
            previewCard.style.opacity = '1';
            fill.style.opacity = '0';

            setTimeout(() => {
              previewCard.removeEventListener('transitionend', handleCardFadeInEnd);
              finishCrossfade();
            }, FILL_FADE_DURATION + 120);
          };

          const resolvedProfile = profile || getOpenMorphProfileForCard(card);

          // Run per-card unique open morph (start/end geometry unchanged).
          const tileAnim = animateOpenTile(
            tile,
            startRect,
            endRect,
            cardRadius,
            targetRadius,
            previewShadow,
            previewBorderColor,
            resolvedProfile
          );

          tileAnim.onfinish = () => {
            startCrossfade();
          };

          setTimeout(() => {
            startCrossfade();
          }, resolvedProfile.duration + 140);
        });
      }

      function closePreview() {
        if (!previewOverlay || !previewOverlay.classList.contains('is-visible')) return;

        const previewCard = previewOverlay.querySelector('.preview-card');
        if (!previewCard) return;

        const previewCardRect = previewCard.getBoundingClientRect();
        if (!lastOpenedCard) {
          previewOverlay.classList.remove('is-visible');
          previewOverlay.setAttribute('aria-hidden', 'true');
          previewCard.classList.remove('is-active');
          previewCard.style.opacity = '';
          previewCard.style.pointerEvents = '';
          if (activeMorphTile && activeMorphTile.parentNode) {
            activeMorphTile.parentNode.removeChild(activeMorphTile);
          }
          activeMorphTile = null;
          unlockScroll();
          lastOpenedCard = null;
          if (typeof window.updateActiveTrackFromWindowScroll === 'function') {
            window.updateActiveTrackFromWindowScroll();
          }
          updateHeroPlaybackState();
          return;
        }
        const cardRect = lastOpenedCard.getBoundingClientRect();

        let tile = activeMorphTile;
        let fill = null;

        if (!tile) {
          const created = createGlowTileFromCard(lastOpenedCard, previewCardRect);
          tile = created.tile;
          fill = created.fill;
          activeMorphTile = tile;
        } else {
          tile.style.borderRadius = getComputedStyle(previewCard).borderRadius;
          tile.style.width = `${previewCardRect.width}px`;
          tile.style.height = `${previewCardRect.height}px`;
          tile.style.transform = `translate(${previewCardRect.left}px, ${previewCardRect.top}px)`;
          tile.classList.remove('is-fade-out');
          tile.style.opacity = '';
          fill = tile.querySelector('.preview-morph-fill');
          if (fill) {
            fill.classList.remove('is-fade-out');
            fill.style.opacity = '1';
            const posterImg = lastOpenedCard.querySelector('img');
            if (posterImg && posterImg.src) {
              fill.style.backgroundImage = `url(${posterImg.src})`;
            }
          }
        }

        previewCard.style.opacity = '0';
        previewCard.style.pointerEvents = 'none';

        previewOverlay.classList.remove('is-visible');
        previewOverlay.setAttribute('aria-hidden', 'true');

        const targetRadius = getComputedStyle(lastOpenedCard).borderRadius;

        // Keep close timing compatible with the last open profile.
        tile.style.setProperty('--preview-morph-duration', `${currentMorphDuration}ms`);
        tile.style.setProperty('--preview-morph-ease', currentMorphEasing);

        requestAnimationFrame(() => {
          tile.offsetHeight;
          moveTile(tile, previewCardRect, cardRect, targetRadius);
        });

        setTimeout(() => {
          previewCard.classList.remove('is-active');
          previewCard.style.opacity = '';
          previewCard.style.pointerEvents = '';

          if (tile && tile.parentNode) {
            tile.parentNode.removeChild(tile);
          }
          if (activeMorphTile === tile) {
            activeMorphTile = null;
          }
          activeMorphTile = null;

          unlockScroll();

          if (lastOpenedCard && document.body.contains(lastOpenedCard)) {
            lastOpenedCard.focus();
          }
          lastOpenedCard = null;
          if (typeof window.updateActiveTrackFromWindowScroll === 'function') {
            window.updateActiveTrackFromWindowScroll();
          }
          updateHeroPlaybackState();
        }, currentMorphDuration);
      }

      previewCloseButton.addEventListener('click', () => {
        closePreview();
      });

      previewOverlay.addEventListener('click', (event) => {
        const previewCard = previewOverlay.querySelector('.preview-card');
        if (!previewCard) return;
        if (previewCard.contains(event.target)) return;
        closePreview();
      });

      document.addEventListener('click', (event) => {
        const previewButton = event.target.closest('.poster-preview-button');
        if (!previewButton) return;

        const card = previewButton.closest('.poster');
        if (!card) return;

        event.preventDefault();
        event.stopPropagation();
        openPreviewFromCard(card, previewButton);
      }, true);

      document.addEventListener('keydown', (event) => {
        // Open preview from focused poster using Enter/Space.
        if ((event.key === 'Enter' || event.key === ' ') && !previewOverlay.classList.contains('is-visible')) {
          const active = document.activeElement;
          const card = active ? active.closest('.poster[data-morph-id]') : null;
          if (card) {
            event.preventDefault();
            openPreviewFromCard(card, card);
          }
        }
      });

document.addEventListener('keydown', (event) => {
        if ((event.key === 'Escape' || event.key === 'Esc') && previewOverlay.classList.contains('is-visible')) {
          event.preventDefault();
          closePreview();
        }
      });
    });
  </script>

  <!-- Preview Overlay (static skeleton) -->
  <div class="preview-overlay" aria-hidden="true">
    <div class="preview-card" role="dialog" aria-modal="true" aria-labelledby="preview-title">
      <button class="preview-close-btn" type="button" aria-label="Close preview">Ã—</button>
      <div class="preview-media">
        <!-- Later: video or wide poster goes here -->
        <div class="preview-media-placeholder"></div>
      </div>
      <div class="preview-info">
        <header class="preview-header">
          <h2 id="preview-title" class="preview-title">Preview Placeholder Title</h2>
          <div class="preview-meta">
            <span class="preview-runtime">1h 52m</span>
            <span class="preview-tags">Thriller â€¢ Sciâ€‘Fi â€¢ Action</span>
          </div>
        </header>
        <div class="preview-body">
          <p class="preview-description">
            
            This is a static placeholder description used for layout validation only. It is intentionally long so the text wraps across multiple lines and reveals spacing, rhythm, and hierarchy inside the Preview Modal. Replace this copy with real content in a later task once the layout has been visually approved.
          
          </p>
        </div>
        <div class="preview-actions">
          <button class="preview-play-button" type="button">
            Play
          </button>
          <button class="preview-details-button" type="button">
            Details
          </button>
        </div>
      </div>
    </div>
  </div>



<script>
  // ZAQ TASK 1 â€” "Zero Tolerance" Magnetic Pull
  (function(){
    const SETTLE_DELAY_MS = 420;   // Wait for scroll to settle
    const HERO_SETTLE_DELAY_MS = 620;
    const PULL_DURATION_MS = 1500;  // Slow, confident glide
    const HERO_PULL_DURATION_MS = 1800;
    const MAX_SPACER_PX = 240;
    const SPACER_BUFFER_PX = 16;

    let scrollEndTimer = null;
    let lastScrollAt = 0;
    let pullAnimRaf = null;
    let shelfTargets = null;
    
    const snapState = window.snapState || (window.snapState = {
      isSnapping: false,
      activeSnapTrack: null,
      activeSnapTop: null
    });

    // Guard: Prevent double-firing, but reset instantly on interaction
    let userScrolledSinceLastPull = true;

    function cancelPull(){
      if (pullAnimRaf) cancelAnimationFrame(pullAnimRaf);
      pullAnimRaf = null;
      snapState.isSnapping = false;
      snapState.activeSnapTrack = null;
      snapState.activeSnapTop = null;
    }

    // Easing: ease-in-out for gentle ramp-up and soft landing
    function easeInOutCubic(x) {
      return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    }

    function computeCenterTargetTop(el){
      if (!el) return 0;
      const r = el.getBoundingClientRect();
      const y = window.scrollY || window.pageYOffset || 0;
      const centerAbs = (r.top + y) + (r.height / 2);
      return centerAbs - (window.innerHeight / 2);
    }

    function clamp(v, min, max){
      if (v < min) return min;
      if (v > max) return max;
      return v;
    }

    function maxScrollTop(){
      const doc = document.documentElement;
      const body = document.body;
      return Math.max(0, Math.max(
        doc.scrollHeight, body.scrollHeight,
        doc.offsetHeight, body.offsetHeight,
        doc.clientHeight
      ) - window.innerHeight);
    }

    let cachedBottomSpacer = 0;
    const getBottomSpacer = () => document.getElementById('mobile-bottom-spacer');

    function applyBottomSpacer(heightPx){
      const spacer = getBottomSpacer();
      if (!spacer) return;
      spacer.style.setProperty('--mobile-bottom-spacer-height', heightPx > 0 ? `${heightPx}px` : '0px');
    }

    function updateTargets(allowSpacerUpdate){
      const hero = document.querySelector('.hero');
      const rowA = document.querySelector('.shelf-track[data-row="A"]');
      const rowB = document.querySelector('.shelf-track[data-row="B"]');
      const rowC = document.querySelector('.shelf-track[data-row="C"]');
      
      if (!hero || !rowA || !rowB || !rowC) return;

      if (allowSpacerUpdate) {
        const currentMax = maxScrollTop() - cachedBottomSpacer;
        const rowCTarget = computeCenterTargetTop(rowC);
        const needed = rowCTarget - currentMax;
        
        let nextSpacer = 0;
        if (needed > 0) nextSpacer = Math.min(MAX_SPACER_PX, Math.ceil(needed + SPACER_BUFFER_PX));
        
        if (nextSpacer !== cachedBottomSpacer) {
           cachedBottomSpacer = nextSpacer;
           applyBottomSpacer(nextSpacer);
        }
      }

      const maxY = maxScrollTop();
      const heroTop = clamp(computeCenterTargetTop(hero), 0, maxY);
      shelfTargets = [
        { top: heroTop, track: hero },
        { top: clamp(computeCenterTargetTop(rowA), 0, maxY), track: rowA },
        { top: clamp(computeCenterTargetTop(rowB), 0, maxY), track: rowB },
        { top: clamp(computeCenterTargetTop(rowC), 0, maxY), track: rowC }
      ];
    }

    function softPullTo(targetTop, targetTrack, durationMs){
      cancelPull();
      const startY = window.scrollY || window.pageYOffset || 0;
      const delta = targetTop - startY;

      // DEADZONE KILLER: We pull even if it's just 1px off.
      if (!isFinite(delta) || Math.abs(delta) < 1) return;

      const startTime = performance.now();
      snapState.isSnapping = true;
      snapState.activeSnapTop = targetTop;
      snapState.activeSnapTrack = targetTrack || null;
      
      userScrolledSinceLastPull = false;

      function step(now){
        const tRaw = (now - startTime) / durationMs;
        const t = tRaw < 0 ? 0 : (tRaw > 1 ? 1 : tRaw);
        
        const eased = easeInOutCubic(t);
        const nextY = startY + (delta * eased);
        
        window.scrollTo(0, nextY);

        if (t < 1) {
          pullAnimRaf = requestAnimationFrame(step);
        } else {
          window.scrollTo(0, targetTop);
          snapState.isSnapping = false;
          snapState.activeSnapTrack = null;
          pullAnimRaf = null;
        }
      }
      pullAnimRaf = requestAnimationFrame(step);
    }

    function attemptSoftPull(){
      if (snapState.isSnapping) return;
      if (!userScrolledSinceLastPull) return;

      updateTargets(true);
      if (!shelfTargets || shelfTargets.length < 1) return;

      // 1. Check for Visual Priority (Red Glow)
      const activeHero = document.querySelector('.hero.hero--active');
      const activeTrack = document.querySelector('.shelf-track--active');
      let target = null;

      if (activeHero) {
        target = shelfTargets.find(t => t.track === activeHero);
      }

      if (!target && activeTrack) {
        target = shelfTargets.find(t => t.track === activeTrack);
      }
      
      // 2. Fallback: Nearest neighbor
      if (!target) {
         const y = window.scrollY || window.pageYOffset || 0;
         let nearest = shelfTargets[0];
         let bestDist = Math.abs(y - nearest.top);
         for (let i = 1; i < shelfTargets.length; i++) {
           const d = Math.abs(y - shelfTargets[i].top);
           if (d < bestDist) {
             bestDist = d;
             nearest = shelfTargets[i];
           }
         }
         target = nearest;
      }

      if (!target) return;

      const now = performance.now();
      const isHeroTarget = target.track && target.track.classList && target.track.classList.contains('hero');
      const settleDelay = isHeroTarget ? HERO_SETTLE_DELAY_MS : SETTLE_DELAY_MS;
      if (now - lastScrollAt < settleDelay) {
        schedulePull(settleDelay - (now - lastScrollAt));
        return;
      }

      const duration = isHeroTarget ? HERO_PULL_DURATION_MS : PULL_DURATION_MS;
      softPullTo(target.top, target.track, duration);
    }

    function schedulePull(delayMs = SETTLE_DELAY_MS){
      if (scrollEndTimer) clearTimeout(scrollEndTimer);
      scrollEndTimer = setTimeout(attemptSoftPull, delayMs);
    }

    // --- Interaction Handling ---
    const onUserInteraction = () => {
      cancelPull();
      if (scrollEndTimer) clearTimeout(scrollEndTimer);
      userScrolledSinceLastPull = true; 
    };

    window.addEventListener('wheel', onUserInteraction, { passive: true });
    window.addEventListener('touchstart', onUserInteraction, { passive: true });
    window.addEventListener('touchmove', onUserInteraction, { passive: true });
    
    window.addEventListener('touchend', () => {
       userScrolledSinceLastPull = true;
    }, { passive: true });
    
    window.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','PageUp','PageDown','Home','End',' '].includes(e.key)) {
        onUserInteraction();
      }
    }, { passive: true });

    window.addEventListener('scroll', () => {
      if (snapState.isSnapping) return;
      lastScrollAt = performance.now();
      onUserInteraction();
      schedulePull();
    }, { passive: true });

    const refresh = () => {
      onUserInteraction();
      requestAnimationFrame(() => updateTargets(true));
    };
    window.addEventListener('resize', refresh, { passive: true });
    window.addEventListener('orientationchange', refresh, { passive: true });

    document.addEventListener('DOMContentLoaded', () => {
      updateTargets(true);
    });
  })();
</script>


<script>
/* Desktop-only: lock footer once it would naturally appear, then add scroll runway behind it
   so Row C can reach true center. Unlock when scrolling back above the trigger. */
(function(){
  const footer = document.querySelector('footer');
  const sentinel = document.getElementById('footer-lock-sentinel');
  const placeholder = document.getElementById('footer-placeholder');
  const runway = document.getElementById('desktop-bottom-runway');

  if(!footer || !sentinel || !placeholder || !runway) return;

  const DESKTOP_MQ = window.matchMedia('(min-width: 1024px)');

  let triggerScrollY = 0;
  let locked = false;

  function docY(el){
    const r = el.getBoundingClientRect();
    return (window.scrollY || window.pageYOffset || 0) + r.top;
  }

  function computeTrigger(){
    // Trigger when sentinel would enter the viewport from the bottom (i.e., footer would become visible).
    const sentinelY = docY(sentinel);
    triggerScrollY = sentinelY - (window.innerHeight - 1);
  }

  function computeNeededRunwayPx(){
    const rowC = document.querySelector('.shelf-track[data-row="C"]') || document.getElementById('row-c-title');
    if(!rowC) return 0;

    const footerH = footer.getBoundingClientRect().height || footer.offsetHeight || 0;
    const usableH = Math.max(1, window.innerHeight - footerH);

    const rowRect = rowC.getBoundingClientRect();
    const rowCenterDocY = (window.scrollY || 0) + rowRect.top + (rowRect.height / 2);

    // Want Row C center to align with the center of the *usable* viewport (above fixed footer).
    const desiredScrollTop = rowCenterDocY - (usableH / 2);

    // Current max scroll before runway.
    const maxScrollTop = Math.max(0, document.documentElement.scrollHeight - window.innerHeight);

    const extra = desiredScrollTop - maxScrollTop;
    // Small safety buffer so we don't land exactly on the clamp.
    return Math.max(0, Math.ceil(extra + 24));
  }

  function applyLockedState(){
    footer.classList.add('footer--locked');

    const footerH = Math.ceil(footer.getBoundingClientRect().height || footer.offsetHeight || 0);
    placeholder.style.height = footerH + 'px';

    runway.style.height = computeNeededRunwayPx() + 'px';
  }

  function clearLockedState(){
    footer.classList.remove('footer--locked');
    placeholder.style.height = '0px';
    runway.style.height = '0px';
  }

  function lock(){
    if(locked) return;
    locked = true;
    applyLockedState();
  }

  function unlock(){
    if(!locked) return;
    locked = false;
    clearLockedState();
  }

  function ensureCorrectState(){
    if(!DESKTOP_MQ.matches){
      unlock();
      computeTrigger();
      return;
    }

    const y = window.scrollY || window.pageYOffset || 0;

    if(!locked && y >= triggerScrollY){
      lock();
      return;
    }

    // Hysteresis to prevent flicker right at the boundary.
    if(locked && y < (triggerScrollY - 12)){
      unlock();
      return;
    }
  }

  // Init
  computeTrigger();
  ensureCorrectState();

  window.addEventListener('scroll', ensureCorrectState, { passive:true });

  function onResize(){
    computeTrigger();
    if(locked) applyLockedState();
    ensureCorrectState();
  }

  window.addEventListener('resize', onResize, { passive:true });
  window.addEventListener('orientationchange', onResize, { passive:true });

  // If fonts/images shift layout after load, recompute once more.
  window.addEventListener('load', onResize, { passive:true });
})();
</script>

</body>
</html>
